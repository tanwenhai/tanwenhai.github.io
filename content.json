{"meta":{"title":"hgg","subtitle":null,"description":"php,linux,javascript,nodejs,node,python,java","author":"tanwenhai","url":"http://tanwenhai.github.com"},"pages":[],"posts":[{"title":"docker","date":"2017-11-11T12:57:35.000Z","path":"2017/11/11/docker/","text":"容器运行容器1docker run -itd twh/java 查看容器1docker ps -a 删除容器1docker rm $(docker container ls -a -q) 连接后台运行中的容器1docker attach twh/java 该命令有时候不方便，因为是同步的，若有多个用户attach到一个容器，一个窗口命令阻塞，其他窗口都无法执行 1docker exec -it twh/java 导出容器1docker export 容器ID &gt; java.tar.gz 镜像查找镜像1docker search mysql -s 100 拉取镜像1docker pull mysql 删除镜像1docker rmi 镜像ID 保存镜像1docker save -o java.tar.gz twh/java 导入镜像1cat java.tar.gz|docker import - twh/java:v1.0.1 docker 私有仓库搭建 获取registry镜像 1docker pull registry 运行镜像 -p端口映射 -v数据卷 1docker run -d -p 5000:5000 -v /data/docker/registry:/tmp/registry registry 上传镜像 1docker push 192.168.3.3:5000/java","content":"<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><h3 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -itd twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker ps -a</div></pre></td></tr></table></figure>\n<h3 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker rm $(docker container ls -a -q)</div></pre></td></tr></table></figure>\n<h3 id=\"连接后台运行中的容器\"><a href=\"#连接后台运行中的容器\" class=\"headerlink\" title=\"连接后台运行中的容器\"></a>连接后台运行中的容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker attach twh/java</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>该命令有时候不方便，因为是同步的，若有多个用户attach到一个容器，一个窗口命令阻塞，其他窗口都无法执行</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker <span class=\"built_in\">exec</span> -it twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker <span class=\"built_in\">export</span> 容器ID &gt; java.tar.gz</div></pre></td></tr></table></figure>\n<h1 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h1><h3 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker search mysql -s 100</div></pre></td></tr></table></figure>\n<h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull mysql</div></pre></td></tr></table></figure>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker rmi 镜像ID</div></pre></td></tr></table></figure>\n<h3 id=\"保存镜像\"><a href=\"#保存镜像\" class=\"headerlink\" title=\"保存镜像\"></a>保存镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker save -o java.tar.gz twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"导入镜像\"><a href=\"#导入镜像\" class=\"headerlink\" title=\"导入镜像\"></a>导入镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat java.tar.gz|docker import - twh/java:v1.0.1</div></pre></td></tr></table></figure>\n<h1 id=\"docker-私有仓库搭建\"><a href=\"#docker-私有仓库搭建\" class=\"headerlink\" title=\"docker 私有仓库搭建\"></a>docker 私有仓库搭建</h1><ol>\n<li><p>获取registry镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull registry</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行镜像 -p端口映射 -v数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -p 5000:5000 -v /data/docker/registry:/tmp/registry registry</div></pre></td></tr></table></figure>\n</li>\n<li><p>上传镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker push 192.168.3.3:5000/java</div></pre></td></tr></table></figure></li>\n</ol>\n","tags":[{"name":"docker","slug":"docker","permalink":"http://tanwenhai.github.com/tags/docker/"}]},{"title":"jinfo:JAVA进程运行时修改虚拟机参数利器（无需重启）","date":"2017-11-11T09:00:50.000Z","path":"2017/11/11/jinfo/","text":"转 http://www.open-open.com/lib/view/open1437018491912.html 虚拟机总会有出现问题的时候，并且你深深的知道如果通过配置一些参数使得虚拟机打印一些运行时信息，可以通过这种途径改善虚拟机的运行状况。如 XX:+HeapDumpOnOutOfMemoryError和XX:+PrintGCDetails。但是有时候这些参数会丢失，这是件令人头痛的事情。因此，你痛苦的耸了耸肩，杀掉虚拟机进程，修改启动参数并祈祷之前的糟糕状况可以在重新启动之后重现。现在你拥有足够的证据来查找问题的根源，并改正。前面描述的方式，很显然需要一次额外的重启并添加一些调试参数。实际上，不需要重启虚拟机的方法是有的，这种方法好处是大大的。JDK打包工具里面为我们提供了一个很好的小工具。jinfo是一个命令行工具，通过这个工具可以获取JAVA进程运行时的一些信息，通过使用jinfo 和一些参数，可以动态修改JAVA进程的虚拟机参数，这些参数并不是万能的，但是在一些场景中是非常有用的。虚拟机的这些参数可以通过下面的命令查看：12345678910111213141516171819202122$ java -XX:+PrintFlagsFinal -version| grep manageable intx CMSAbortablePrecleanWaitMillis = 100 &#123;manageable&#125; intx CMSTriggerInterval = -1 &#123;manageable&#125; intx CMSWaitDuration = 2000 &#123;manageable&#125; bool HeapDumpAfterFullGC = false &#123;manageable&#125; bool HeapDumpBeforeFullGC = false &#123;manageable&#125; bool HeapDumpOnOutOfMemoryError = false &#123;manageable&#125; ccstr HeapDumpPath = &#123;manageable&#125; uintx MaxHeapFreeRatio = 100 &#123;manageable&#125; uintx MinHeapFreeRatio = 0 &#123;manageable&#125; bool PrintClassHistogram = false &#123;manageable&#125; bool PrintClassHistogramAfterFullGC = false &#123;manageable&#125; bool PrintClassHistogramBeforeFullGC = false &#123;manageable&#125; bool PrintConcurrentLocks = false &#123;manageable&#125; bool PrintGC = false &#123;manageable&#125; bool PrintGCDateStamps = false &#123;manageable&#125; bool PrintGCDetails = false &#123;manageable&#125; bool PrintGCID = false &#123;manageable&#125; bool PrintGCTimeStamps = false &#123;manageable&#125;java version \"1.8.0_112\"Java(TM) SE Runtime Environment (build 1.8.0_112-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode) 我们通过-XX:+PrintFlagsFinal -version参数可以获取JVM的所有选项，然而manageable才是我们所感兴趣的，通过JDK的管理接口（com.sun.management.HotSpotDiagnosticMCBean API）可以动态写入。非常相似的MBean也可以通过Jconsole查看，对于我来说命令行的方式是非常方便的。下面是一个使用jinfo的例子：我们通过动态打开JVM的GC日志开关例子来演示jinfo如何使用。我们先通过jps来查看当前运行状态的虚拟机进程：123$ jps -l31907 app.jar5574 sun.tools.jps.Jps 我们通过使用jinfo来打开虚拟机GC日志打印参数，-XX:+PrintGC和-XX:+PrintGCDetails。使用命令行方式微小的差别在于需要为jinfo同时指定-XX:+PrintGC和-XX:+PrintGCDetails参数。除了通过启动脚本可以设置参数，PrintGC默认是打开的，因此我们只需要打开PrintGCDetails参数。12$ jinfo -flag +PrintGCDDetails 31907$ jinfo -flag +PrintGC 31907","content":"<blockquote>\n<p>转 <a href=\"http://www.open-open.com/lib/view/open1437018491912.html\" target=\"_blank\" rel=\"external\">http://www.open-open.com/lib/view/open1437018491912.html</a></p>\n</blockquote>\n<p>虚拟机总会有出现问题的时候，并且你深深的知道如果通过配置一些参数使得虚拟机打印一些运行时信息，可以通过这种途径改善虚拟机的运行状况。如 XX:+HeapDumpOnOutOfMemoryError和XX:+PrintGCDetails。但是有时候这些参数会丢失，这是件令人头痛的事情。<br>因此，你痛苦的耸了耸肩，杀掉虚拟机进程，修改启动参数并祈祷之前的糟糕状况可以在重新启动之后重现。现在你拥有足够的证据来查找问题的根源，并改正。前面描述的方式，很显然需要一次额外的重启并添加一些调试参数。实际上，不需要重启虚拟机的方法是有的，这种方法好处是大大的。<br>JDK打包工具里面为我们提供了一个很好的小工具。jinfo是一个命令行工具，通过这个工具可以获取JAVA进程运行时的一些信息，通过使用jinfo 和一些参数，可以动态修改JAVA进程的虚拟机参数，这些参数并不是万能的，但是在一些场景中是非常有用的。虚拟机的这些参数可以通过下面的命令查看：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ java -XX:+PrintFlagsFinal -version| grep manageable</div><div class=\"line\">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;</div><div class=\"line\">     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;</div><div class=\"line\">     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpAfterFullGC                       = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpBeforeFullGC                      = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpOnOutOfMemoryError                = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;</div><div class=\"line\">    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;</div><div class=\"line\">    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogram                       = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogramAfterFullGC            = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogramBeforeFullGC           = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintConcurrentLocks                      = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGC                                   = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCDateStamps                         = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCDetails                            = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCID                                 = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCTimeStamps                         = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">java version <span class=\"string\">\"1.8.0_112\"</span></div><div class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</div><div class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</div></pre></td></tr></table></figure></p>\n<p>我们通过-XX:+PrintFlagsFinal -version参数可以获取JVM的所有选项，然而manageable才是我们所感兴趣的，通过JDK的管理接口（com.sun.management.HotSpotDiagnosticMCBean API）可以动态写入。非常相似的MBean也可以通过Jconsole查看，对于我来说命令行的方式是非常方便的。<br>下面是一个使用jinfo的例子：<br>我们通过动态打开JVM的GC日志开关例子来演示jinfo如何使用。<br>我们先通过jps来查看当前运行状态的虚拟机进程：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jps -l</div><div class=\"line\">31907 app.jar</div><div class=\"line\">5574 sun.tools.jps.Jps</div></pre></td></tr></table></figure></p>\n<p>我们通过使用jinfo来打开虚拟机GC日志打印参数，-XX:+PrintGC和-XX:+PrintGCDetails。使用命令行方式微小的差别在于需要为jinfo同时指定-XX:+PrintGC和-XX:+PrintGCDetails参数。除了通过启动脚本可以设置参数，PrintGC默认是打开的，因此我们只需要打开PrintGCDetails参数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jinfo -flag +PrintGCDDetails 31907</div><div class=\"line\">$ jinfo -flag +PrintGC 31907</div></pre></td></tr></table></figure></p>\n","tags":[{"name":"linux jinfo","slug":"linux-jinfo","permalink":"http://tanwenhai.github.com/tags/linux-jinfo/"}]},{"title":"微服务和单体应用对比","date":"2017-11-06T13:38:46.000Z","path":"2017/11/06/微服务和单体应用对比/","text":"单体应用容易部署、测试随功能演进越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高 复杂性高 技术债务 可靠性差 扩展能力受限 阻碍技术创新 微服务具有以下优点 易于开发和维护 单个微服务启动较快 局部修改容易部署 技术栈不受限 按需伸缩","content":"<blockquote>\n<p>单体应用容易部署、测试随功能演进越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高</p>\n</blockquote>\n<ol>\n<li>复杂性高</li>\n<li>技术债务</li>\n<li>可靠性差</li>\n<li>扩展能力受限</li>\n<li>阻碍技术创新</li>\n</ol>\n<blockquote>\n<p>微服务具有以下优点</p>\n</blockquote>\n<ol>\n<li>易于开发和维护</li>\n<li>单个微服务启动较快</li>\n<li>局部修改容易部署</li>\n<li>技术栈不受限</li>\n<li>按需伸缩</li>\n</ol>\n","tags":[]},{"title":"linux iostat","date":"2017-11-06T07:24:38.000Z","path":"2017/11/06/linux-iostat/","text":"简介 iostat主要用于监控系统设备的IO负载情况，iostat首次运行时显示自系统启动开始的各项统计信息，之后运行iostat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。 -d 显示设备（磁盘）使用状态 -k 指定iostat的部分输出结果以kB为单位，而不是以扇区数为单位 -c 显示更详细的io设备统计信息1234567891011121314151617$ iostat -dkx 1 5Linux 2.6.32-696.1.1.el6.x86_64 (iZuf650me9vkz4vfzq4htwZ) 11/06/2017 _x86_64_ (4 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.02 26.90 0.28 1.23 10.82 112.50 164.15 0.08 53.10 6.34 63.66 1.95 0.29Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 2.00 0.00 2.00 0.00 16.00 16.00 0.00 1.00 0.00 1.00 1.00 0.20Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 rrqm/s 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并 wrqm/s 每秒对该设备的写请求被合并次数 r/s 每秒完成的读取次数 w/s 每秒完成的写次数 rkB/s 每秒读数据量(kB为单位) wkB/s 每秒写数据量(kB为单位) avgrq-sz 平均每次IO操作的数据量(扇区数为单位) avgqu-sz 平均等待处理的IO请求队列长度 await 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位) r_await 平均每次IO请求读等待时间 w_await 平均每次IO请求写等待时间 svctm 平均每次IO请求的处理时间(毫秒为单位) %util 采集周期内用于IO操作的时间比率，即IO队列非空的时间比率","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>iostat主要用于监控系统设备的IO负载情况，iostat首次运行时显示自系统启动开始的各项统计信息，之后运行iostat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。</p>\n</blockquote>\n<ol>\n<li><strong>-d</strong> 显示设备（磁盘）使用状态</li>\n<li><strong>-k</strong> 指定iostat的部分输出结果以kB为单位，而不是以扇区数为单位</li>\n<li><strong>-c</strong> 显示更详细的io设备统计信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ iostat -dkx 1 5</div><div class=\"line\">Linux 2.6.32-696.1.1.el6.x86_64 (iZuf650me9vkz4vfzq4htwZ) \t11/06/2017 \t_x86_64_\t(4 CPU)</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.02    26.90    0.28    1.23    10.82   112.50   164.15     0.08   53.10    6.34   63.66   1.95   0.29</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     2.00    0.00    2.00     0.00    16.00    16.00     0.00    1.00    0.00    1.00   1.00   0.20</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><strong>rrqm/s</strong> 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li>\n<li><strong>wrqm/s</strong> 每秒对该设备的写请求被合并次数</li>\n<li><strong>r/s</strong> 每秒完成的读取次数</li>\n<li><strong>w/s</strong> 每秒完成的写次数</li>\n<li><strong>rkB/s</strong> 每秒读数据量(kB为单位)</li>\n<li><strong>wkB/s</strong> 每秒写数据量(kB为单位)</li>\n<li><strong>avgrq-sz</strong> 平均每次IO操作的数据量(扇区数为单位)</li>\n<li><strong>avgqu-sz</strong> 平均等待处理的IO请求队列长度</li>\n<li><strong>await</strong> 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li>\n<li><strong>r_await</strong> 平均每次IO请求读等待时间</li>\n<li><strong>w_await</strong> 平均每次IO请求写等待时间</li>\n<li><strong>svctm</strong> 平均每次IO请求的处理时间(毫秒为单位)</li>\n<li><strong>%util</strong> 采集周期内用于IO操作的时间比率，即IO队列非空的时间比率</li>\n</ul>\n","tags":[{"name":"linux iostat","slug":"linux-iostat","permalink":"http://tanwenhai.github.com/tags/linux-iostat/"}]},{"title":"linux vmstat","date":"2017-11-06T06:44:23.000Z","path":"2017/11/06/linux-vmstat/","text":"vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如: 12345678910111213$ vmstat 1 10procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 129616 6552 1734536 0 0 3 28 0 0 2 0 97 0 0 0 0 0 129352 6552 1734636 0 0 0 172 1644 1196 4 1 96 0 0 0 0 0 129352 6552 1734668 0 0 0 0 1338 1164 3 1 97 0 0 1 0 0 129632 6552 1734932 0 0 0 0 2695 2396 14 1 85 0 0 1 0 0 128640 6560 1735324 0 0 0 16 2208 2082 11 1 88 0 0 0 0 0 128252 6560 1735692 0 0 0 0 1361 1024 7 1 92 0 0 0 0 0 128244 6560 1735756 0 0 0 16 854 831 2 1 97 0 0 1 0 0 128384 6560 1735828 0 0 0 0 1651 1289 4 1 95 0 0 0 0 0 128260 6560 1735872 0 0 0 0 1178 995 2 1 97 0 0 0 0 0 128260 6568 1735900 0 0 0 20 1086 958 2 0 98 0 0 第一个参数表示每隔多久采集一次 第二个参数是总共采集次数 r 表示运行队列 b 表示阻塞的进程 swpd 交换分区虚拟内存已使用的大小 free 空闲的物理内存的大小 buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存 cache cache直接用来记忆我们打开的文件,给文件做缓冲 si 每秒从磁盘读入虚拟内存(交换分区)的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了 so 每秒虚拟内存写入磁盘的大小(交换分区)，如果这个值大于0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 in 每秒CPU的中断次数，包括时间中断 cs 每秒上下文切换次数，调用系统函数、线程的切换需要进程上下文切换，这个值要越小越好 us 用户CPU时间(用户态) sy 系统CPU时间(系统态) id CPU空闲时间 一般来说，id + us + sy = 100 wa 等待IO CPU时间。 st 未知","content":"<p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。</p>\n<blockquote>\n<p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vmstat 1 10</span></div><div class=\"line\">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</div><div class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class=\"line\"> 0  0      0 129616   6552 1734536    0    0     3    28    0    0  2  0 97  0  0</div><div class=\"line\"> 0  0      0 129352   6552 1734636    0    0     0   172 1644 1196  4  1 96  0  0</div><div class=\"line\"> 0  0      0 129352   6552 1734668    0    0     0     0 1338 1164  3  1 97  0  0</div><div class=\"line\"> 1  0      0 129632   6552 1734932    0    0     0     0 2695 2396 14  1 85  0  0</div><div class=\"line\"> 1  0      0 128640   6560 1735324    0    0     0    16 2208 2082 11  1 88  0  0</div><div class=\"line\"> 0  0      0 128252   6560 1735692    0    0     0     0 1361 1024  7  1 92  0  0</div><div class=\"line\"> 0  0      0 128244   6560 1735756    0    0     0    16  854  831  2  1 97  0  0</div><div class=\"line\"> 1  0      0 128384   6560 1735828    0    0     0     0 1651 1289  4  1 95  0  0</div><div class=\"line\"> 0  0      0 128260   6560 1735872    0    0     0     0 1178  995  2  1 97  0  0</div><div class=\"line\"> 0  0      0 128260   6568 1735900    0    0     0    20 1086  958  2  0 98  0  0</div></pre></td></tr></table></figure>\n<blockquote>\n<p>第一个参数表示每隔多久采集一次 第二个参数是总共采集次数</p>\n<ul>\n<li><strong>r</strong> 表示运行队列</li>\n<li><strong>b</strong> 表示阻塞的进程</li>\n<li><strong>swpd</strong> 交换分区虚拟内存已使用的大小</li>\n<li><strong>free</strong> 空闲的物理内存的大小</li>\n<li><strong>buff</strong> Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存</li>\n<li><strong>cache</strong> cache直接用来记忆我们打开的文件,给文件做缓冲</li>\n<li><strong>si</strong> 每秒从磁盘读入虚拟内存(交换分区)的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了</li>\n<li><strong>so</strong> 每秒虚拟内存写入磁盘的大小(交换分区)，如果这个值大于0，同上。</li>\n<li><strong>bi</strong> 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte</li>\n<li><strong>bo</strong> 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</li>\n<li><strong>in</strong> 每秒CPU的中断次数，包括时间中断</li>\n<li><strong>cs</strong> 每秒上下文切换次数，调用系统函数、线程的切换需要进程上下文切换，这个值要越小越好</li>\n<li><strong>us</strong> 用户CPU时间(用户态)</li>\n<li><strong>sy</strong> 系统CPU时间(系统态)</li>\n<li><strong>id</strong> CPU空闲时间 一般来说，id + us + sy = 100</li>\n<li><strong>wa</strong> 等待IO CPU时间。</li>\n<li><strong>st</strong> 未知</li>\n</ul>\n</blockquote>\n","tags":[{"name":"linux vmstat","slug":"linux-vmstat","permalink":"http://tanwenhai.github.com/tags/linux-vmstat/"}]},{"title":"spring IoC容器的实现","date":"2017-11-01T06:58:31.000Z","path":"2017/11/01/spring-IoC容器的实现/","text":"IoC控制反转 依赖对象不由自身实现，由外部注入，在具体的注入实现中，接口注入、setter注入和构造器注入是主要的注入方式 对象生成或初始化时直接将数据注入到对象中 通过将对象引用注入到对象数据域中 在Spring IoC容器的设计中，有两个主要的容器系列，一个是实现BeanFactory接口的简单容器系列，另一个是ApplicationContext应用上下文，应用上下文在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配。 在这些Spring提供的基本IoC容器的接口定义和实现的基础上，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系，BeanDefinition抽象了对Bean的定义，对Ioc容器来说BeanDefinition就是对依赖反转模式中管理的对象依赖关系 IoC容器的初始化过程由AbstractApplicationContext#refresh开始,包括BeanDefinition载入、注入 第一个过程是Resource定位，Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resouce接口来完成 第二个过程是BeanDefinition的载入，载入过程是把用户定义的Bean表示成IoC容器内部的数据结构 第三个过程是向Ioc容器注册这些BeanDefinition的过程，通过调用BeanDefinitionRegistry接口的实现来完成","content":"<ol>\n<li>IoC控制反转 依赖对象不由自身实现，由外部注入，在具体的注入实现中，接口注入、setter注入和构造器注入是主要的注入方式<ul>\n<li>对象生成或初始化时直接将数据注入到对象中</li>\n<li>通过将对象引用注入到对象数据域中</li>\n</ul>\n</li>\n<li>在Spring IoC容器的设计中，有两个主要的容器系列，一个是实现BeanFactory接口的简单容器系列，另一个是ApplicationContext应用上下文，<strong>应用上下文在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配</strong>。<ul>\n<li><img src=\"/2017/11/01/spring-IoC容器的实现/BeanFactory.png\" alt=\"BeanFactory继承图\" title=\"BeanFactory继承图\"></li>\n<li>在这些Spring提供的基本IoC容器的接口定义和实现的基础上，Spring通过<strong>定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系</strong>，BeanDefinition抽象了对Bean的定义，对Ioc容器来说BeanDefinition就是对依赖反转模式中管理的对象依赖关系</li>\n<li><img src=\"/2017/11/01/spring-IoC容器的实现/IoC容器接口设计图.png\" alt=\"IoC容器接口设计图\" title=\"IoC容器接口设计图\"></li>\n</ul>\n</li>\n<li>IoC容器的初始化过程由<em>AbstractApplicationContext#refresh</em>开始,包括BeanDefinition载入、注入<ul>\n<li>第一个过程是Resource定位，Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resouce接口来完成</li>\n<li>第二个过程是BeanDefinition的载入，载入过程是把用户定义的Bean表示成IoC容器内部的数据结构</li>\n<li>第三个过程是向Ioc容器注册这些BeanDefinition的过程，通过调用BeanDefinitionRegistry接口的实现来完成</li>\n</ul>\n</li>\n</ol>\n","tags":[{"name":"spring","slug":"spring","permalink":"http://tanwenhai.github.com/tags/spring/"}]},{"title":"Hystrix","date":"2017-10-02T07:39:13.000Z","path":"2017/10/02/Hystrix/","text":"使用注解@EnableCircuitBreaker启用断路功能HystrixCommand: 用在依赖的服务返回单个操作结果的时候HystrixObservableCommand: 用在依赖的服务返回多个操作结果的时候","content":"<p>使用注解@EnableCircuitBreaker启用断路功能<br>HystrixCommand: 用在依赖的服务返回单个操作结果的时候<br>HystrixObservableCommand: 用在依赖的服务返回多个操作结果的时候</p>\n","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://tanwenhai.github.com/tags/spring-cloud/"}]},{"title":"Ribbon","date":"2017-09-30T01:19:07.000Z","path":"2017/09/30/Ribbon/","text":"Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具通过@LoadBalancer给RestTemplate增加服务负载均衡支持 创建一个LoadBalancerInterceptor的Bean,用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡 创建了一个RestTemplateCustomizer的Bean,用于给RestTemplate增加LoadBalancerInterceptor拦截器 维护了一个被@LoadBalanced注解修饰的RestTemplate对象列表，并初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载均衡的RestTemplate增加LoadBalancerInterceptor拦截器","content":"<p>Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具<br>通过@LoadBalancer给RestTemplate增加服务负载均衡支持</p>\n<ol>\n<li>创建一个LoadBalancerInterceptor的Bean,用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡</li>\n<li>创建了一个RestTemplateCustomizer的Bean,用于给RestTemplate增加LoadBalancerInterceptor拦截器</li>\n<li>维护了一个被@LoadBalanced注解修饰的RestTemplate对象列表，并初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载均衡的RestTemplate增加LoadBalancerInterceptor拦截器</li>\n</ol>\n","tags":[{"name":"Spring Cloud Ribbon","slug":"Spring-Cloud-Ribbon","permalink":"http://tanwenhai.github.com/tags/Spring-Cloud-Ribbon/"}]},{"title":"nginx location指令","date":"2017-02-14T07:50:11.000Z","path":"2017/02/14/nginx-location指令/","text":"12345678910111213141516171819location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; configuration A 精确匹配 path=/ configuration B 匹配 path=/* 如 /index.html configuration C 匹配 path=/documents/* 如 /documents/document.html configuration D 正则唯一匹配 path=/images/* 如 /images/1.gif configuration E 正则不区分大小写匹配 *.(gif|jpg|jpeg) 如 /documents/1.jpg","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">location = / &#123;</div><div class=\"line\">    [ configuration A ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location / &#123;</div><div class=\"line\">    [ configuration B ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location /documents/ &#123;</div><div class=\"line\">    [ configuration C ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location ^~ /images/ &#123;</div><div class=\"line\">    [ configuration D ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location ~* \\.(gif|jpg|jpeg)$ &#123;</div><div class=\"line\">    [ configuration E ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>configuration A 精确匹配 path=/</li>\n<li>configuration B 匹配 path=/* 如 /index.html</li>\n<li>configuration C 匹配 path=/documents/* 如 /documents/document.html</li>\n<li>configuration D 正则唯一匹配 path=/images/* 如 /images/1.gif</li>\n<li>configuration E 正则不区分大小写匹配 *.(gif|jpg|jpeg) 如 /documents/1.jpg</li>\n</ul>\n","tags":[{"name":"nginx","slug":"nginx","permalink":"http://tanwenhai.github.com/tags/nginx/"}]},{"title":"使用dblib连接sybase","date":"2017-02-14T07:17:14.000Z","path":"2017/02/14/使用dblib连接sybase/","text":"安装freetds 1yum install freetds freetds-dev 安装pdo_dblib扩展 12pecl install pdo_dblibphp --ri pdo_dblib # 验证扩展是否安装 pdo连接 12345678$dsn = 'dblib:appname=PHP freetds;host=localhost:12345;dbname=abc';$user = 'username';$passwd = 'password';try &#123; $dbh = new \\PDO($dsn, $user, $passwd);&#125; catch(\\PDOException $e) &#123; echo $e -&gt;getMessage();&#125; *yum源没有freetds123wget http://www6.atomicorp.com/channels/atomic/centos/7/x86_64/RPMS/atomic-release*rpmrpm -Uvh atomic-release*rpmyum install freetds","content":"<ol>\n<li><p>安装freetds</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install freetds freetds-dev</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装pdo_dblib扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pecl install pdo_dblib</div><div class=\"line\">php --ri pdo_dblib <span class=\"comment\"># 验证扩展是否安装</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>pdo连接</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$dsn = <span class=\"string\">'dblib:appname=PHP freetds;host=localhost:12345;dbname=abc'</span>;</div><div class=\"line\">$user = <span class=\"string\">'username'</span>;</div><div class=\"line\">$passwd = <span class=\"string\">'password'</span>;</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    $dbh = <span class=\"keyword\">new</span> \\PDO($dsn, $user, $passwd);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(\\PDOException $e) &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> $e -&gt;getMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>*yum源没有freetds<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www6.atomicorp.com/channels/atomic/centos/7/x86_64/RPMS/atomic-release*rpm</div><div class=\"line\">rpm -Uvh atomic-release*rpm</div><div class=\"line\">yum install freetds</div></pre></td></tr></table></figure></p>\n","tags":[{"name":"php","slug":"php","permalink":"http://tanwenhai.github.com/tags/php/"}]},{"title":"数据库软件推荐","date":"2017-02-14T07:11:12.000Z","path":"2017/02/14/数据库软件推荐/","text":"DBeaver 支持数据库多Navicat Premium 收费的 这个没有链接地址哦","content":"<p><a href=\"http://dbeaver.jkiss.org/download/\" target=\"_blank\" rel=\"external\">DBeaver</a> 支持数据库多<br>Navicat Premium 收费的 这个没有链接地址哦</p>\n","tags":[{"name":"soft","slug":"soft","permalink":"http://tanwenhai.github.com/tags/soft/"}]},{"title":"10 件在 PHP 7 中不要做的事情","date":"2017-02-14T06:55:16.000Z","path":"2017/02/14/10-件在-PHP-7-中不要做的事情/","text":"不要使用mysql_函数 这一天终于来了，从此你不仅仅“不应该”使用mysql函数。PHP 7 已经把它们从核心中全部移除了，也就是说你需要迁移到好得多的mysqli函数，或者更灵活的 PDO 实现。 不要编写垃圾代码 这一条可能易于理解，但是会变得越来越重要，因为 PHP 7 的速度提升可能会隐藏你的一些问题。不要仅仅满足于你的站点速度，因为迁移到 PHP 7 才让它变快。为了理解速度有多重要，以及如何把事情做得更好，请看一看我们的文章速度优化入门指南。作为一名开发者，你应该总是确保按需加载脚本，尽可能连接它们，编写高效的数据库查询，尽可能使用缓存，以及其它。 不要在文件末尾使用 PHP 闭合标签 你可以看一看，当一个文件以 PHP 代码结尾时，WordPress 多数核心代码都把末尾的 PHP 标签去掉了。实际上，Zend 框架特别禁止了它。PHP 并不需要文件末尾的闭合标签，并且我们可以通过去掉它来保证不会在后面添加任何的空白字符。 不要做不必要的引用传递 我个人不喜欢引用传递。我知道有时候它很实用，但是其它情况下它使代码变得难懂，并且更难预测结果。据说一些人认为它使代码运行更快，但是根据一些 PHP 高级程序员所说，这并不正确。说明引用为什么不好的一个例子是，PHP 内建了shuffle()和sort()。它们修改原始数组，而不是返回处理后的数组，这很不合逻辑。 不要在循环中执行查询 在循环中执行查询非常浪费。它给你的系统施加不必要的压力，并且可能能够在循环外部更快获得相同结果。当我遇到需要这样的情况时，我通常会使用两个分离的查询来解决问题，我会使用它们来构建数据数组。之后我会遍历数组，并不需要在这个过程中执行查询。由于 WordPress 适用于这里，它可能有一些例外。虽然get_post_meta() 会从数据库获取大量数据，如果你正在遍历某个特殊博文的元数据你可以在循环中使用它。这是因为当你第一次调用它的时候，WordPress实际上会获取所有元数据并缓存它们。后续的调用使用这些缓存数据，没有数据库的调用。弄懂这些的最佳方式是阅读函数文档，以及使用类似 Query Monitor 的工具 不要在 SQL 查询中使用* 当然，这个更像 MySQL 的问题，但是我们习惯在 PHP 中编写 SQL 代码，所以都差不多。无论如何，如果可以避免的话，不要在 SQL 查询里使用通配符，尤其是数据库有很多列的时候。你应该明确指定需要哪些行，并且仅仅获取它们。这有助于减少所用资源，保护数据，以及让事情变得尽可能清晰。对于 SQL，你需要了解所有可用的函数，并且尽可能测试其速度。在计算均值、求和或计算类似数值时，要使用 SQL 函数而不是 PHP 函数。如果你不确定某个查询的速度，测试它并且尝试一些其它的编译 – 之后使用最好的那个。 不要信任用户输入 信任用户输入是不明智的。始终校验、过滤、转义、检查并留好退路。用户数据存在三个问题：我们开发者并没有考虑每种可能性，它通常不正确，以及它可能是蓄意破坏。经过周密考虑的系统可以防护这些威胁。要确保使用类似filter_var()的内建函数检查适当的值，以及在处理数据库时转义（或预编译）。WordPress 拥有一些函数来解决问题。详见文章校验、转义和过滤用户数据。 不要故作聪明 你的目标应该是编写优雅的代码，来更清晰地表达你的意图。你可能能够通过将任何东西缩短为一个单词的变量，使用多层的三元逻辑，以及其它手段，从每个页面中优化 0.01 秒。但这只会给你和你周围的人产生大麻烦。合理命名变量，为代码编写文档，优先选择清晰而不是简洁。甚至还可以更好，使用标准的面向对象代码，它本身或多或少就是文档，不需要一大堆内联数值。 不要重新发明轮子 PHP 到现在为止有很长时间了，网站被造出来的时间更长。很可能无论你需要造出什么，一些人之前早就造出来了。不要害怕向他人寻求支持，Github是你的好朋友，Composer也是，Packagist也是。从日志工具到调色工具，从性能分析器到单元测试框架，从 Mailchimp API 到 Twitter Bootstrap，每个东西都可以通过按下按键（或者敲下命令）来获取，使用它们吧！ 不要忽略其它语言 如果你是个 PHP 程序员，现在有个好机会去至少了解 HTML、CSS、JavaScript 和 MySQL。当你能够更好地处理这些语言时，就是重新学习 JavaScript 的时机了。JavaScript 并不是 jQuery，你应该合理地学习 JavaScript 来更高效地使用它。我也打算向你推荐学习面向对象的 PHP，它可以节省时间，并且在代码规模更大时会变得更好。对于类似 C# 和 Java 的语言，在你了解 OOP 之后，它们也更易于理解。通过了解包管理器、构建脚本、CoffeeScript、LESS、SASS、YAML 、脚本引擎和其它强大的工具来扩展你的知识面。我强烈向你推荐看一看其它框架，尤其是 Laravel。当你使用它们出色完成任务时，学习 Ruby、RoR、Android、iPhone 和 Windows Phone 应用开发如何？你可能会认为这毫无意义，因为它们在你的舒适区和工作所需范围之外，但是这就是它们的意义。每种语言都有一些要学习的实用的东西，以及从没碰到的新知识。所有 PHP 顶级开发者都懂得很多其它编程语言，这并非偶然。 来源segmentfault","content":"<ol>\n<li><p>不要使用mysql_函数</p>\n<blockquote>\n<p>这一天终于来了，从此你不仅仅“不应该”使用mysql<em>函数。PHP 7 已经把它们从核心中全部移除了，也就是说你需要迁移到好得多的mysqli</em>函数，或者更灵活的 PDO 实现。</p>\n</blockquote>\n</li>\n<li><p>不要编写垃圾代码</p>\n<blockquote>\n<p>这一条可能易于理解，但是会变得越来越重要，因为 PHP 7 的速度提升可能会隐藏你的一些问题。<br>不要仅仅满足于你的站点速度，因为迁移到 PHP 7 才让它变快。<br>为了理解速度有多重要，以及如何把事情做得更好，请看一看我们的文章速度优化入门指南。作为一名开发者，你应该总是确保按需加载脚本，尽可能连接它们，编写高效的数据库查询，尽可能使用缓存，以及其它。</p>\n</blockquote>\n</li>\n<li><p>不要在文件末尾使用 PHP 闭合标签</p>\n<blockquote>\n<p>你可以看一看，当一个文件以 PHP 代码结尾时，WordPress 多数核心代码都把末尾的 PHP 标签去掉了。实际上，Zend 框架特别禁止了它。<br>PHP 并不需要文件末尾的闭合标签，并且我们可以通过去掉它来保证不会在后面添加任何的空白字符。</p>\n</blockquote>\n</li>\n<li><p>不要做不必要的引用传递</p>\n<blockquote>\n<p>我个人不喜欢引用传递。我知道有时候它很实用，但是其它情况下它使代码变得难懂，并且更难预测结果。<br>据说一些人认为它使代码运行更快，但是根据一些 PHP 高级程序员所说，这并不正确。<br>说明引用为什么不好的一个例子是，PHP 内建了shuffle()和sort()。它们修改原始数组，而不是返回处理后的数组，这很不合逻辑。</p>\n</blockquote>\n</li>\n<li><p>不要在循环中执行查询</p>\n<blockquote>\n<p>在循环中执行查询非常浪费。它给你的系统施加不必要的压力，并且可能能够在循环外部更快获得相同结果。当我遇到需要这样的情况时，我通常会使用两个分离的查询来解决问题，我会使用它们来构建数据数组。之后我会遍历数组，并不需要在这个过程中执行查询。<br>由于 WordPress 适用于这里，它可能有一些例外。虽然get_post_meta() 会从数据库获取大量数据，如果你正在遍历某个特殊博文的元数据你可以在循环中使用它。这是因为当你第一次调用它的时候，WordPress实际上会获取所有元数据并缓存它们。后续的调用使用这些缓存数据，没有数据库的调用。<br>弄懂这些的最佳方式是阅读函数文档，以及使用类似 Query Monitor 的工具</p>\n</blockquote>\n</li>\n<li><p>不要在 SQL 查询中使用*</p>\n<blockquote>\n<p>当然，这个更像 MySQL 的问题，但是我们习惯在 PHP 中编写 SQL 代码，所以都差不多。无论如何，如果可以避免的话，不要在 SQL 查询里使用通配符，尤其是数据库有很多列的时候。<br>你应该明确指定需要哪些行，并且仅仅获取它们。这有助于减少所用资源，保护数据，以及让事情变得尽可能清晰。<br>对于 SQL，你需要了解所有可用的函数，并且尽可能测试其速度。在计算均值、求和或计算类似数值时，要使用 SQL 函数而不是 PHP 函数。如果你不确定某个查询的速度，测试它并且尝试一些其它的编译 – 之后使用最好的那个。</p>\n</blockquote>\n</li>\n<li><p>不要信任用户输入</p>\n<blockquote>\n<p>信任用户输入是不明智的。始终校验、过滤、转义、检查并留好退路。用户数据存在三个问题：我们开发者并没有考虑每种可能性，它通常不正确，以及它可能是蓄意破坏。<br>经过周密考虑的系统可以防护这些威胁。要确保使用类似filter_var()的内建函数检查适当的值，以及在处理数据库时转义（或预编译）。<br>WordPress 拥有一些函数来解决问题。详见文章校验、转义和过滤用户数据。</p>\n</blockquote>\n</li>\n<li><p>不要故作聪明</p>\n<blockquote>\n<p>你的目标应该是编写优雅的代码，来更清晰地表达你的意图。你可能能够通过将任何东西缩短为一个单词的变量，使用多层的三元逻辑，以及其它手段，从每个页面中优化 0.01 秒。但这只会给你和你周围的人产生大麻烦。<br>合理命名变量，为代码编写文档，优先选择清晰而不是简洁。甚至还可以更好，使用标准的面向对象代码，它本身或多或少就是文档，不需要一大堆内联数值。</p>\n</blockquote>\n</li>\n<li><p>不要重新发明轮子</p>\n<blockquote>\n<p>PHP 到现在为止有很长时间了，网站被造出来的时间更长。很可能无论你需要造出什么，一些人之前早就造出来了。不要害怕向他人寻求支持，Github是你的好朋友，Composer也是，Packagist也是。<br>从日志工具到调色工具，从性能分析器到单元测试框架，从 Mailchimp API 到 Twitter Bootstrap，每个东西都可以通过按下按键（或者敲下命令）来获取，使用它们吧！</p>\n</blockquote>\n</li>\n<li><p>不要忽略其它语言</p>\n<blockquote>\n<p>如果你是个 PHP 程序员，现在有个好机会去至少了解 HTML、CSS、JavaScript 和 MySQL。当你能够更好地处理这些语言时，就是重新学习 JavaScript 的时机了。JavaScript 并不是 jQuery，你应该合理地学习 JavaScript 来更高效地使用它。<br>我也打算向你推荐学习面向对象的 PHP，它可以节省时间，并且在代码规模更大时会变得更好。对于类似 C# 和 Java 的语言，在你了解 OOP 之后，它们也更易于理解。<br>通过了解包管理器、构建脚本、CoffeeScript、LESS、SASS、YAML 、脚本引擎和其它强大的工具来扩展你的知识面。我强烈向你推荐看一看其它框架，尤其是 Laravel。<br>当你使用它们出色完成任务时，学习 Ruby、RoR、Android、iPhone 和 Windows Phone 应用开发如何？你可能会认为这毫无意义，因为它们在你的舒适区和工作所需范围之外，但是这就是它们的意义。每种语言都有一些要学习的实用的东西，以及从没碰到的新知识。所有 PHP 顶级开发者都懂得很多其它编程语言，这并非偶然。</p>\n</blockquote>\n</li>\n</ol>\n<p><a href=\"https://segmentfault.com/a/1190000006912969\" target=\"_blank\" rel=\"external\">来源segmentfault</a></p>\n","tags":[{"name":"php","slug":"php","permalink":"http://tanwenhai.github.com/tags/php/"}]}]}