{"meta":{"title":"hgg","subtitle":null,"description":"php,linux,javascript,nodejs,node,python,java","author":"tanwenhai","url":"http://tanwenhai.github.com"},"pages":[{}],"posts":[{"title":"mysql explain","date":"2017-12-21T02:13:18.000Z","path":"2017/12/21/mysql-explain/","text":"EXPLAIN 列 列名 说明 id 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） table 访问引用哪个表（引用某个查询，如“derived3”） type 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） possible_keys 揭示哪一些索引可能有利于高效的查找 key 显示mysql决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节数 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows|为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数|Extra|额外信息，如using index、filesort等 idid是用来顺序标识整个查询中SELELCT 语句的，在嵌套查询中id越大的语句越先执行。该值可能为NULL，如果这一行用来说明的是其他行的联合结果。 select_type表示查询的类型 类型 说明 simple 简单子查询，不包含子查询和union primary 包含union或者子查询，最外层的部分标记为primary subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询 derived 派生表——该临时表是从子查询派生出来的，位于form中的子查询 union 位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived union result 用来从匿名临时表里检索结果的select被标记为union result dependent union 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 subquery 子查询中第一个SELECT语句 dependent subquery 和DEPENDENT UNION相对UNION一样 table对应行正在访问哪一个表，表名或者别名 关联优化器会为查询选择关联顺序，左侧深度优先当from中有子查询的时候，表名是derivedN的形式，N指向子查询，也就是explain结果中的下一列当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id注意：MySQL对待这些表和普通表一样，但是这些“临时表”是没有任何索引的。 typetype显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。 类型 说明 All 最坏的情况,全表扫描 index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 range 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range ref 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 eq_ref 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） system 这是const连接类型的一种特例，表仅有一行满足条件。 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） possible_keys显示查询使用了哪些索引，表示该索引可以进行高效地查找，但是列出来的索引对于后续优化过程可能是没有用的 keykey列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。 key_lenkey_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好 。 refref列显示使用哪个列或常数与key一起从表中选择行。 rowsrows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值。 ExtraExtra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。 类型 说明 Using filesort MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 Using temporary 用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 Not exists MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。 Using index 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。 Using index condition 这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。 Using join buffer 使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接 impossible where where子句的值总是false，不能用来获取任何元组 select tables optimized away 在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作 show warningsshow warnings会看到优化器重写后的sql","content":"<h2 id=\"EXPLAIN-列\"><a href=\"#EXPLAIN-列\" class=\"headerlink\" title=\"EXPLAIN 列\"></a>EXPLAIN 列</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">列名</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">id</td>\n<td style=\"text-align:left\">执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">select_type</td>\n<td style=\"text-align:left\">显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">table</td>\n<td style=\"text-align:left\">访问引用哪个表（引用某个查询，如“derived3”）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">type</td>\n<td style=\"text-align:left\">数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">possible_keys</td>\n<td style=\"text-align:left\">揭示哪一些索引可能有利于高效的查找</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">key</td>\n<td style=\"text-align:left\">显示mysql决定采用哪个索引来优化查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">key_len</td>\n<td style=\"text-align:left\">显示mysql在索引里使用的字节数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ref</td>\n<td style=\"text-align:left\">显示了之前的表在key列记录的索引中查找值所用的列或常量</td>\n</tr>\n</tbody>\n</table>\n<p>rows|为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数<br>|Extra|额外信息，如using index、filesort等</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p>id是用来顺序标识整个查询中SELELCT 语句的，在嵌套查询中id越大的语句越先执行。该值可能为NULL，如果这一行用来说明的是其他行的联合结果。</p>\n<h3 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h3><p>表示查询的类型</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">simple</td>\n<td style=\"text-align:left\">简单子查询，不包含子查询和union</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">primary</td>\n<td style=\"text-align:left\">包含union或者子查询，最外层的部分标记为primary</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">subquery</td>\n<td style=\"text-align:left\">一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">derived</td>\n<td style=\"text-align:left\">派生表——该临时表是从子查询派生出来的，位于form中的子查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">union</td>\n<td style=\"text-align:left\">位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">union result</td>\n<td style=\"text-align:left\">用来从匿名临时表里检索结果的select被标记为union result</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependent union</td>\n<td style=\"text-align:left\">顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">subquery</td>\n<td style=\"text-align:left\">子查询中第一个SELECT语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependent subquery</td>\n<td style=\"text-align:left\">和DEPENDENT UNION相对UNION一样</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h3><p>对应行正在访问哪一个表，表名或者别名</p>\n<p>关联优化器会为查询选择关联顺序，左侧深度优先<br>当from中有子查询的时候，表名是derivedN的形式，N指向子查询，也就是explain结果中的下一列<br>当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id<br>注意：MySQL对待这些表和普通表一样，但是这些“临时表”是没有任何索引的。</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">All</td>\n<td style=\"text-align:left\">最坏的情况,全表扫描</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">index</td>\n<td style=\"text-align:left\">和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">range</td>\n<td style=\"text-align:left\">范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ref</td>\n<td style=\"text-align:left\">一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">eq_ref</td>\n<td style=\"text-align:left\">最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">const</td>\n<td style=\"text-align:left\">当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">system</td>\n<td style=\"text-align:left\">这是const连接类型的一种特例，表仅有一行满足条件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Null</td>\n<td style=\"text-align:left\">意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h3><p>显示查询使用了哪些索引，表示该索引可以进行高效地查找，但是列出来的索引对于后续优化过程可能是没有用的</p>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>\n<h3 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h3><p>key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好 。</p>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><p>ref列显示使用哪个列或常数与key一起从表中选择行。</p>\n<h3 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h3><p>rows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值。</p>\n<h3 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h3><p>Extra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Using filesort</td>\n<td style=\"text-align:left\">MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using temporary</td>\n<td style=\"text-align:left\">用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Not exists</td>\n<td style=\"text-align:left\">MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using index</td>\n<td style=\"text-align:left\">说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using index condition</td>\n<td style=\"text-align:left\">这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using where</td>\n<td style=\"text-align:left\">使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using join buffer</td>\n<td style=\"text-align:left\">使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">impossible where</td>\n<td style=\"text-align:left\">where子句的值总是false，不能用来获取任何元组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">select tables optimized away</td>\n<td style=\"text-align:left\">在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">distinct</td>\n<td style=\"text-align:left\">优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"show-warnings\"><a href=\"#show-warnings\" class=\"headerlink\" title=\"show warnings\"></a>show warnings</h2><p>show warnings会看到优化器重写后的sql</p>\n","tags":[{"name":"mysql","slug":"mysql","permalink":"http://tanwenhai.github.com/tags/mysql/"}]},{"title":"设计模式概述","date":"2017-12-18T08:30:26.000Z","path":"2017/12/18/设计模式概述/","text":"设计模式有什么用 设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。如果一点设计模式都不懂，我想要做到这一点恐怕还是很困难的 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。如果某一天因为升职或跳槽等原因，别人接手了你的项目，只要他也懂设计模式，我想他应该能够很快理解你的设计思路和实现方案，让你升职无后患之忧，跳槽也心安理得，何乐而不为呢？ 最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期” 面向对象设计原则对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。 最常见的7种面向对象设计原则如下表所示： 表1 7种常用的面向对象设计原则 设计原则名称 定义 使用频率 单一职责原则 一个类只负责一个功能领域中的相应职责 ★★★★☆ 开闭原则 软件实体应对扩展开放，而对修改关闭 ★★★★★ 里氏代换原则 所有引用基类对象的地方能够透明地使用其子类的对象 ★★★★★ 依赖倒转原则 抽象不应该依赖于细节，细节应该依赖于抽象 ★★★★★ 接口隔离原则 使用多个专门的接口，而不使用单一的总接口 ★★☆☆☆ 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的 ★★★★☆ 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用 ★★★☆☆ 面向对象设计原则之单一职责原则单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 面向对象设计原则之开闭原则开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 面向对象设计原则之里氏代换原则如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义： 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 面向对象设计原则之依赖倒转原则如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则定义如下： 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 面向对象设计原则之接口隔离原则接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 面向对象设计原则之合成复用原则合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。 面向对象设计原则之迪米特法则迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象； 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。","content":"<h2 id=\"设计模式有什么用\"><a href=\"#设计模式有什么用\" class=\"headerlink\" title=\"设计模式有什么用\"></a>设计模式有什么用</h2><ol>\n<li>设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高</li>\n<li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的</li>\n<li>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。如果一点设计模式都不懂，我想要做到这一点恐怕还是很困难的</li>\n<li>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。如果某一天因为升职或跳槽等原因，别人接手了你的项目，只要他也懂设计模式，我想他应该能够很快理解你的设计思路和实现方案，让你升职无后患之忧，跳槽也心安理得，何乐而不为呢？</li>\n<li>最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期”</li>\n</ol>\n<h2 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h2><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>\n<p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。</p>\n<p>最常见的7种面向对象设计原则如下表所示： 表1 7种常用的面向对象设计原则  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">设计原则名称</th>\n<th style=\"text-align:left\">定义</th>\n<th style=\"text-align:left\">使用频率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">单一职责原则</td>\n<td style=\"text-align:left\">一个类只负责一个功能领域中的相应职责</td>\n<td style=\"text-align:left\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开闭原则</td>\n<td style=\"text-align:left\">软件实体应对扩展开放，而对修改关闭</td>\n<td style=\"text-align:left\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">里氏代换原则</td>\n<td style=\"text-align:left\">所有引用基类对象的地方能够透明地使用其子类的对象</td>\n<td style=\"text-align:left\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">依赖倒转原则</td>\n<td style=\"text-align:left\">抽象不应该依赖于细节，细节应该依赖于抽象</td>\n<td style=\"text-align:left\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">接口隔离原则</td>\n<td style=\"text-align:left\">使用多个专门的接口，而不使用单一的总接口</td>\n<td style=\"text-align:left\">★★☆☆☆</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">合成复用原则</td>\n<td style=\"text-align:left\">尽量使用对象组合，而不是继承来达到复用的目的</td>\n<td style=\"text-align:left\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">迪米特法则</td>\n<td style=\"text-align:left\">一个软件实体应当尽可能少地与其他实体发生相互作用</td>\n<td style=\"text-align:left\">★★★☆☆</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"面向对象设计原则之单一职责原则\"><a href=\"#面向对象设计原则之单一职责原则\" class=\"headerlink\" title=\"面向对象设计原则之单一职责原则\"></a>面向对象设计原则之单一职责原则</h3><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>\n<p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p>\n<h3 id=\"面向对象设计原则之开闭原则\"><a href=\"#面向对象设计原则之开闭原则\" class=\"headerlink\" title=\"面向对象设计原则之开闭原则\"></a>面向对象设计原则之开闭原则</h3><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>\n<p>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p>\n<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p>\n<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>\n<h3 id=\"面向对象设计原则之里氏代换原则\"><a href=\"#面向对象设计原则之里氏代换原则\" class=\"headerlink\" title=\"面向对象设计原则之里氏代换原则\"></a>面向对象设计原则之里氏代换原则</h3><p>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义： 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>\n<p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>\n<p>例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p>\n<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>\n<p>在使用里氏代换原则时需要注意如下几个问题：</p>\n<ol>\n<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>\n<li>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</li>\n<li>Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</li>\n</ol>\n<h3 id=\"面向对象设计原则之依赖倒转原则\"><a href=\"#面向对象设计原则之依赖倒转原则\" class=\"headerlink\" title=\"面向对象设计原则之依赖倒转原则\"></a>面向对象设计原则之依赖倒转原则</h3><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则定义如下： 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>\n<p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p>\n<p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>\n<p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>\n<h3 id=\"面向对象设计原则之接口隔离原则\"><a href=\"#面向对象设计原则之接口隔离原则\" class=\"headerlink\" title=\"面向对象设计原则之接口隔离原则\"></a>面向对象设计原则之接口隔离原则</h3><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>\n<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>\n<ol>\n<li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</li>\n<li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</li>\n</ol>\n<h3 id=\"面向对象设计原则之合成复用原则\"><a href=\"#面向对象设计原则之合成复用原则\" class=\"headerlink\" title=\"面向对象设计原则之合成复用原则\"></a>面向对象设计原则之合成复用原则</h3><p>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。</p>\n<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p>\n<p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>\n<p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</p>\n<h3 id=\"面向对象设计原则之迪米特法则\"><a href=\"#面向对象设计原则之迪米特法则\" class=\"headerlink\" title=\"面向对象设计原则之迪米特法则\"></a>面向对象设计原则之迪米特法则</h3><p>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>\n<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>\n<p>迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>\n<ol>\n<li>当前对象本身(this)；</li>\n<li>以参数形式传入到当前对象方法中的对象；</li>\n<li>当前对象的成员对象；</li>\n<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>\n<li>当前对象所创建的对象。</li>\n</ol>\n","tags":[]},{"title":"数据库ACID和隔离级别","date":"2017-12-13T05:28:53.000Z","path":"2017/12/13/Mysql数据库ACID和隔离级别/","text":"ACID如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性： 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 原子性的核心是：利用一个undo日志来记录事务可以回滚的各个数据版本。即当目前执行的事务发生故障时，需要回滚，可以根据undo日志中的记录来知道事务回滚到哪一步停止。这样来保证事务由当下状态回滚到开始执行前的状态。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 数据库隔离级别当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题： 脏读 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 MySQL数据库为我们提供的四种隔离级别： Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 事务隔离级别最高，并发性最差，利用排它锁实现。针对同一资源，将所有的请求事务进行排序，一一个顺序执行。最高限度的保证了数据的一致性。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 利用共享锁和排写锁实现。读读并行，禁止任何写事务并行 Read committed (读已提交)：可避免脏读的发生。 允许读后写并行。读到的任何数据都是提交的数据，避免读到中间的未提交的数据。但是无法避免不可重复读。因为读事务第一次读取数据之后，另一个写事务可能会修改此事务，导致读事务第二次读取数据和第一次所读到的不一样。但是这种场景并不是经常出现，系统的一致性可以接受，因此多数数据库的默认级别是读已提交。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 对所有事务只加写锁，不加读锁。即只有写写不可以并行。但是这回导致读事务读到一些中间状态的数据，即脏读。 InnoDB行锁实现方式InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ MVCCMVCC(多版本并发控制)，是一种不利用锁机制实现的隔离级别，主要实现了在保证数据的一致性的前提下，实现了读写的并行。之前提到的读已提交，虽然实现了读写并行，读未提交实现了写读并行，读写并行；但是两种隔离级别均没有保证数据的一致性，分别出现不可重复读和脏读。mvcc的原理是给每一数据的更新都有一个版本号。当写事务正在进行时，此时过来一个读事务，读事务会首先生成一个版本号，即该事物想读取哪一个版本的数据。然后，写事务更新数据，读事务读取之前相应版本的数据，而保证了不出现不可重复读和脏读的情况。","content":"<h1 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h1><p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：</p>\n<ol>\n<li><h2 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h2> 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。<br> 原子性的核心是：利用一个undo日志来记录事务可以回滚的各个数据版本。即当目前执行的事务发生故障时，需要回滚，可以根据undo日志中的记录来知道事务回滚到哪一步停止。这样来保证事务由当下状态回滚到开始执行前的状态。</li>\n<li><h2 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h2> 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>\n<li><h2 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h2> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>\n<li><h2 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h2> 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ol>\n<h1 id=\"数据库隔离级别\"><a href=\"#数据库隔离级别\" class=\"headerlink\" title=\"数据库隔离级别\"></a>数据库隔离级别</h1><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>\n<ol>\n<li><h2 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h2> 脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>\n<li><h2 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h2> 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li>\n<li><h2 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h2> 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li>\n</ol>\n<p>MySQL数据库为我们提供的四种隔离级别：  </p>\n<ol>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。  <blockquote>\n<p>事务隔离级别最高，并发性最差，利用排它锁实现。针对同一资源，将所有的请求事务进行排序，一一个顺序执行。最高限度的保证了数据的一致性。</p>\n</blockquote>\n</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。  <blockquote>\n<p>利用共享锁和排写锁实现。读读并行，禁止任何写事务并行</p>\n</blockquote>\n</li>\n<li>Read committed (读已提交)：可避免脏读的发生。<blockquote>\n<p>允许读后写并行。读到的任何数据都是提交的数据，避免读到中间的未提交的数据。但是无法避免不可重复读。因为读事务第一次读取数据之后，另一个写事务可能会修改此事务，导致读事务第二次读取数据和第一次所读到的不一样。但是这种场景并不是经常出现，系统的一致性可以接受，因此多数数据库的默认级别是读已提交。</p>\n</blockquote>\n</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<blockquote>\n<p>对所有事务只加写锁，不加读锁。即只有写写不可以并行。但是这回导致读事务读到一些中间状态的数据，即脏读。</p>\n<h1 id=\"InnoDB行锁实现方式\"><a href=\"#InnoDB行锁实现方式\" class=\"headerlink\" title=\"InnoDB行锁实现方式\"></a>InnoDB行锁实现方式</h1><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h1><p>MVCC(多版本并发控制)，是一种<strong>不利用锁机制实现的隔离级别</strong>，主要实现了在保证数据的一致性的前提下，实现了读写的并行。之前提到的读已提交，虽然实现了读写并行，读未提交实现了写读并行，读写并行；但是两种隔离级别均没有保证数据的一致性，分别出现不可重复读和脏读。<br>mvcc的原理是给每一数据的更新都有一个版本号。当写事务正在进行时，此时过来一个读事务，读事务会首先生成一个版本号，即该事物想读取哪一个版本的数据。然后，写事务更新数据，读事务读取之前相应版本的数据，而保证了不出现不可重复读和脏读的情况。</p>\n","tags":[{"name":"mysql, database","slug":"mysql-database","permalink":"http://tanwenhai.github.com/tags/mysql-database/"}]},{"title":"Java SE API技巧","date":"2017-12-08T02:21:30.000Z","path":"2017/12/08/Java-SE性能调优/","text":"缓冲式I/O 使用二进制数据的文件I/O，使用一个BufferedInputStream或BufferedOutputStream来包装底层的文件流。对于使用字符数据的文件I/O，使用BufferedReader或BufferedWriter来包装底层的流 类加载 Java的类加载器使用了双亲委派模型，一个类加载器在收到加载类的请求后，首先会把这个请求委派给父类加载器去完成，每隔层次的类加载器都如此处理，一个到启动类加载器；如果启动类加载器无法完成加载请求，才会沿这个路径返回，找到合适的类加载器。 在存在多个类加载器的复杂应用中，让这些类加载器支持并行，可以解决系统类加载器或者类加载器上的瓶颈问题。如果应用时在单线程内，则通过一个类加载器加载很多类，关掉Java支持并行的特性可能会有好处 随机数 Java默认的Random类的初始化的成本很高，但是一旦初始化完毕，就可以重用。 在多线程代码中，应该首选ThreadLocalRandom类。 异常 处理异常的代价未必会很高，不过还是应该在适合的时候采用。 栈越深，处理异常的代价越高。 字符串 一行的字符串连接代码性能很不错。 对于多行的连接操作，一定要确保使用StringBuilder。 集合 确定集合的大小减少扩容的性能损耗 根据集合使用情况选择具体的集合类","content":"<h1 id=\"缓冲式I-O\"><a href=\"#缓冲式I-O\" class=\"headerlink\" title=\"缓冲式I/O\"></a>缓冲式I/O</h1><ol>\n<li>使用二进制数据的文件I/O，使用一个BufferedInputStream或BufferedOutputStream来包装底层的文件流。对于使用字符数据的文件I/O，使用BufferedReader或BufferedWriter来包装底层的流</li>\n</ol>\n<h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><ol>\n<li>Java的类加载器使用了双亲委派模型，一个类加载器在收到加载类的请求后，首先会把这个请求委派给父类加载器去完成，每隔层次的类加载器都如此处理，一个到启动类加载器；如果启动类加载器无法完成加载请求，才会沿这个路径返回，找到合适的类加载器。</li>\n<li>在存在多个类加载器的复杂应用中，让这些类加载器支持并行，可以解决系统类加载器或者类加载器上的瓶颈问题。<br>如果应用时在单线程内，则通过一个类加载器加载很多类，关掉Java支持并行的特性可能会有好处</li>\n</ol>\n<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ol>\n<li>Java默认的Random类的初始化的成本很高，但是一旦初始化完毕，就可以重用。</li>\n<li>在多线程代码中，应该首选ThreadLocalRandom类。</li>\n</ol>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><ol>\n<li>处理异常的代价未必会很高，不过还是应该在适合的时候采用。</li>\n<li>栈越深，处理异常的代价越高。</li>\n</ol>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><ol>\n<li>一行的字符串连接代码性能很不错。</li>\n<li>对于多行的连接操作，一定要确保使用StringBuilder。</li>\n</ol>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><ol>\n<li>确定集合的大小减少扩容的性能损耗</li>\n<li>根据集合使用情况选择具体的集合类</li>\n</ol>\n","tags":[{"name":"Java","slug":"Java","permalink":"http://tanwenhai.github.com/tags/Java/"}]},{"title":"Java EE性能调优","date":"2017-12-07T01:33:38.000Z","path":"2017/12/07/Java-EE性能调优/","text":"Web容器的基本性能 减少输出 减少服务器产生的结果输出可以加快返回到浏览器的速度。 合并CSS和JavaScript资源 压缩输出 不要使用jsp动态编译 线程池应用服务器通不只有一个线程池。一个线程池用来处理servlet的请求，另一个处理远程EJB请求，第三个则可以处理JMS请求 解析和编组概述给定一组XML或JSON字符串，程序必须将其转换成适合Java处理的数据。依据程序的上下文和输出结果，这个过程被称为编组(marshal)或解析。返回来从数据生成XML或JSON串则称为解组。一般来说，处理这些数据涉及以下四种技术。标识符解析器(Token parser) 解析器遍历输入数据中的标识符，当发现标识符时则回调相应对象上的方法。拉模式解析器(Pull parser) 输入的数据与解析器关联，程序从解析器中请求标识符文档模型(Document model) 输入数据被转换成文档风格的对象，以便程序在查找数据片段时可以遍历。对象呈现(Object representation) 通过与输入数据对应的预定类，可以将数据转换成一个或多个Java对象","content":"<h1 id=\"Web容器的基本性能\"><a href=\"#Web容器的基本性能\" class=\"headerlink\" title=\"Web容器的基本性能\"></a>Web容器的基本性能</h1><ol>\n<li>减少输出<br>　减少服务器产生的结果输出可以加快返回到浏览器的速度。</li>\n<li>合并CSS和JavaScript资源</li>\n<li>压缩输出</li>\n<li>不要使用jsp动态编译</li>\n</ol>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><p>应用服务器通不只有一个线程池。一个线程池用来处理servlet的请求，另一个处理远程EJB请求，第三个则可以处理JMS请求</p>\n<h1 id=\"解析和编组概述\"><a href=\"#解析和编组概述\" class=\"headerlink\" title=\"解析和编组概述\"></a>解析和编组概述</h1><p>给定一组XML或JSON字符串，程序必须将其转换成适合Java处理的数据。依据程序的上下文和输出结果，这个过程被称为编组(marshal)或解析。返回来从数据生成XML或JSON串则称为解组。<br>一般来说，处理这些数据涉及以下四种技术。<br>标识符解析器(Token parser)<br>　解析器遍历输入数据中的标识符，当发现标识符时则回调相应对象上的方法。<br>拉模式解析器(Pull parser)<br>　输入的数据与解析器关联，程序从解析器中请求标识符<br>文档模型(Document model)<br>　输入数据被转换成文档风格的对象，以便程序在查找数据片段时可以遍历。<br>对象呈现(Object representation)<br>  通过与输入数据对应的预定类，可以将数据转换成一个或多个Java对象</p>\n","tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"http://tanwenhai.github.com/tags/JavaEE/"}]},{"title":"jvm垃圾收集器","date":"2017-12-04T06:08:30.000Z","path":"2017/12/04/jvm垃圾收集器/","text":"垃圾收集概述垃圾收集由两步构成：查找不再使用的对象，释放这些对象所管理的内存。jvm从查找不再使用的对象入手。jvm通过定期扫描来查找不再使用的对象。一旦发现垃圾对象，jvm会回收这些对象所持有的内存，把他们分配给需要内存的其他对象。 分代垃圾收集器虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代。这些代被称为老年代和新生代。新生代又被进一步划分为不同的区段，分别称为Eden空间和Survivor空间，采用分代机制的原因是很多对象的生产时间非常短。新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍在使用的对象会被移动到其他地方。这种操作被称为Minor GC。对象不断的移动到老年代，最终老年代也会被填满，jvm需要找出老年代中不再使用的对象，并对它们进行回收，简单的垃圾收集算法直接停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对堆空间进行整理。这个过程被称为Full GC。 GC算法jvm提供以下4种不同的垃圾收集算法。 Serial(串行)垃圾收集器Serial垃圾收集器是四种垃圾收集器中最简单的一种。Serial使用单线程清理堆内容，无论是进行Minor GC还是Full GC，清理堆空间时，所有的应用线程都会被暂停。进行Full GC时，他还会对老年代空间的对象进行压缩整理。通过-XX:+UseSerialGC标志可以启用Serial收集器 Throughput(吞吐量)垃圾收集器Throughput收集器是Server级虚拟机的默认收集器。Throughput收集器使用多线程回收新生代空间，Minor GC的速度比使用Serial收集器快得多。处理老年代时Throughput收集器也能使用多线程方式。由于Thoughput收集器使用多线程也常常被称为Paraller收集器。Thoughput收集器在Minor GC和Full GC时会暂停所有的应用线程，同时在Full GC过程中会对老年代空间进行压缩整理。 CMS收集器CMS收集器在Full GC时不再暂停应用线程，而是使用肉若干个后台线程定期对老年嗲空间进行扫描，及时回收其中不再使用的对象。这种算法帮助CMS成为一个低延迟的收集器：应用线程只在Minor GC以及后台线程扫描老年代时发生极其短暂的停顿。应用程序线程停顿的总时长与使用Throughput收集器比起来短得多额外付出的代价时更高的CPU使用：必须有足够的CPU资源用于运行后台的垃圾收集线程，在应用程序线程运行的同时扫描堆的使用情况。除此之外，后台线程不再进行任何压缩整理的工作，这意味着堆会逐渐变得碎片化。如果CMS的后台线程无法获得完成他们任务所需的CPU资源，或者如果堆变得过度碎片化以至于无法找到连续空间分配对象，CMS就蜕化到Serial收集器的行为：暂停所有应用线程，使用单线程回收、整理老年代空间，这之后又恢复到并发运行，再次启动后台线程。通过-XX:UseConvMarkSweepGC、-XXUseParNewGC标志启用CMS垃圾收集器。 G1垃圾收集器G1垃圾收集算法将堆划分为若干个区域，不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然使用采用暂停所有应用线程的方式，将存活对象移动到老年代或者Survivor空间。同其他的收集算法一样，这些操作也利用多线程的方式完成。G1收集器属于Concurrent收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1收集器实现了堆的压缩整理。因此，使用G1收集器的堆不太容易发碎片化。通过标志-XX:UseG1GC启用G1垃圾收集器。 GC调优虽然处理堆时各种GC算法有所差异，但是他们的基本配置参数时一致的。 调整堆的大小与其他的性能问题一样，选择堆的大小其实时一种平衡。如果分配的堆过于小，程序大部分时间可能都消耗在GC上，没有足够的时间去运行应用程序的逻辑。但是，简单粗暴地设置一个特别大的堆也不是解决问题的办法。GC停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长。这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。调整堆大小时首要的原则就是永远不要将堆的容量设置得比机器的物理内存还打，除此之外，还需要为jvm自身一级机器上其他应用程序预留一部分的内存空间堆的大小由2个参数值空之：分别是初始值(-Xms)和最大值(-Xmx)，可以将堆的初始值和最大值直接设置为一样的数值。这种设置能稍微提高GC的运行效率，因为它不再需要估算堆是否需要调整大小了。 代空间的调整一旦堆的大小确定下来，jvm就需要决定分配多少堆给新生代空间，多少给老年代空间。如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少，老年代相对比较小，比较容易被填满，会更频繁地触发Full GC。不同的GC算法尝试使用不同的方法来解决这些平衡问题。虽然方法不同，不过所有的GC方法都使用了同一套标志来设置代的大小所有用于调整代空间的命令行标志调整的都是新生代空间，新生代空间剩下的所有空间都被老年代占用 -XX:NewRatio=N 设置新生代与老年代的空间占用比率。初始新生代大小 = 初始堆大小 / (1 + NewRatio) -XX:NewSize=N 设置新生代空间的初始大小 -XX:MaxNewSize=N 设置新生代空间的最大大小 -XmnN 将NewSize和MaxNewSize设定为同一个值的快捷方法 永久代和元空间的调整jvm载入类的时候，需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在Java 8称为元空间(Metaspace)，Java 8之前称为永久代永久代和元空间并不完全一样。永久代保存了一些与数据无关的杂项对象，这些对象在Java 8中移到了普通的堆空间内。除此之外，Java 8从根本上改变了保存在这个特殊区域内的元数据类型。使用元空间替换掉永久代的优势之一时不再需要对其进行调整 控制并发除Serial收集器之外几乎所有的垃圾收集器使用的算法都基于多线程。启动的线程数由-XX:ParallelGCThreads=N参数控制几乎所有的垃圾收集算法中基本的垃圾回收线程数都依据机器上的CPU数目计算得出，多个jvm运行于同一台物理机上时，计算得出的线程数可能过高，需进行优化 垃圾回收工具多开启GC日志，使用-verbose:gc或-XX:+PrintGC这两个标志中的任意一个能创建基本的GC日志。使用-XX:+PringGCDetails标志会创建更详细的GC日志，使用-XX:+PrintGCTimeStamps或-XX:PrintGCDateStamps，便于更精确地判断GC操作之间的时间，使用-Xloggc:filename标志修改输出到某个文件，使用日志循环标志可以限制保存在GC日志中的数据量。通过-XX:+UseGCLogfileRotaion -XX:NumberOfGCLogFiles=N -XX:GCLogfilesSize=N标志控制日志文件的循环GC Histogram能够读入GC日志，根据日志文件中的数据生成对应的图表和表格。使用jconsole可以实时监控堆的使用情况使用jstat监控应用程序的垃圾回收过程1234567$ jstat -gcutil 28833 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 66.63 0.00 65.51 46.64 94.45 91.38 330 27.059 12 0.859 27.918 66.63 0.00 65.60 46.64 94.45 91.38 330 27.059 12 0.859 27.918 66.63 0.00 65.60 46.64 94.45 91.38 330 27.059 12 0.859 27.918 66.63 0.00 65.60 46.64 94.45 91.38 330 27.059 12 0.859 27.918 66.63 0.00 65.63 46.64 94.45 91.38 330 27.059 12 0.859 27.918","content":"<h1 id=\"垃圾收集概述\"><a href=\"#垃圾收集概述\" class=\"headerlink\" title=\"垃圾收集概述\"></a>垃圾收集概述</h1><p>垃圾收集由两步构成：查找不再使用的对象，释放这些对象所管理的内存。jvm从查找不再使用的对象入手。jvm通过定期扫描来查找不再使用的对象。一旦发现垃圾对象，jvm会回收这些对象所持有的内存，把他们分配给需要内存的其他对象。</p>\n<h2 id=\"分代垃圾收集器\"><a href=\"#分代垃圾收集器\" class=\"headerlink\" title=\"分代垃圾收集器\"></a>分代垃圾收集器</h2><p>虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代。这些代被称为老年代和新生代。新生代又被进一步划分为不同的区段，分别称为Eden空间和Survivor空间，采用分代机制的原因是很多对象的生产时间非常短。<br>新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍在使用的对象会被移动到其他地方。这种操作被称为Minor GC。<br>对象不断的移动到老年代，最终老年代也会被填满，jvm需要找出老年代中不再使用的对象，并对它们进行回收，简单的垃圾收集算法直接停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对堆空间进行整理。这个过程被称为Full GC。</p>\n<h3 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h3><p>jvm提供以下4种不同的垃圾收集算法。</p>\n<ol>\n<li>Serial(串行)垃圾收集器<br>Serial垃圾收集器是四种垃圾收集器中最简单的一种。Serial使用单线程清理堆内容，无论是进行Minor GC还是Full GC，清理堆空间时，所有的应用线程都会被暂停。进行Full GC时，他还会对老年代空间的对象进行压缩整理。通过-XX:+UseSerialGC标志可以启用Serial收集器</li>\n<li>Throughput(吞吐量)垃圾收集器<br>Throughput收集器是Server级虚拟机的默认收集器。Throughput收集器使用多线程回收新生代空间，Minor GC的速度比使用Serial收集器快得多。处理老年代时Throughput收集器也能使用多线程方式。由于Thoughput收集器使用多线程也常常被称为Paraller收集器。Thoughput收集器在Minor GC和Full GC时会暂停所有的应用线程，同时在Full GC过程中会对老年代空间进行压缩整理。</li>\n<li>CMS收集器<br>CMS收集器在Full GC时不再暂停应用线程，而是使用肉若干个后台线程定期对老年嗲空间进行扫描，及时回收其中不再使用的对象。这种算法帮助CMS成为一个低延迟的收集器：应用线程只在Minor GC以及后台线程扫描老年代时发生极其短暂的停顿。应用程序线程停顿的总时长与使用Throughput收集器比起来短得多<br>额外付出的代价时更高的CPU使用：必须有足够的CPU资源用于运行后台的垃圾收集线程，在应用程序线程运行的同时扫描堆的使用情况。除此之外，后台线程不再进行任何压缩整理的工作，这意味着堆会逐渐变得碎片化。如果CMS的后台线程无法获得完成他们任务所需的CPU资源，或者如果堆变得过度碎片化以至于无法找到连续空间分配对象，CMS就蜕化到Serial收集器的行为：暂停所有应用线程，使用单线程回收、整理老年代空间，这之后又恢复到并发运行，再次启动后台线程。<br>通过-XX:UseConvMarkSweepGC、-XXUseParNewGC标志启用CMS垃圾收集器。</li>\n<li>G1垃圾收集器<br>G1垃圾收集算法将堆划分为若干个区域，不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然使用采用暂停所有应用线程的方式，将存活对象移动到老年代或者Survivor空间。同其他的收集算法一样，这些操作也利用多线程的方式完成。<br>G1收集器属于Concurrent收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1收集器实现了堆的压缩整理。因此，使用G1收集器的堆不太容易发碎片化。通过标志-XX:UseG1GC启用G1垃圾收集器。</li>\n</ol>\n<h2 id=\"GC调优\"><a href=\"#GC调优\" class=\"headerlink\" title=\"GC调优\"></a>GC调优</h2><p>虽然处理堆时各种GC算法有所差异，但是他们的基本配置参数时一致的。</p>\n<h3 id=\"调整堆的大小\"><a href=\"#调整堆的大小\" class=\"headerlink\" title=\"调整堆的大小\"></a>调整堆的大小</h3><p>与其他的性能问题一样，选择堆的大小其实时一种平衡。如果分配的堆过于小，程序大部分时间可能都消耗在GC上，没有足够的时间去运行应用程序的逻辑。但是，简单粗暴地设置一个特别大的堆也不是解决问题的办法。GC停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长。这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。<br>调整堆大小时首要的原则就是永远不要将堆的容量设置得比机器的物理内存还打，除此之外，还需要为jvm自身一级机器上其他应用程序预留一部分的内存空间<br>堆的大小由2个参数值空之：分别是初始值(-Xms)和最大值(-Xmx)，可以将堆的初始值和最大值直接设置为一样的数值。这种设置能稍微提高GC的运行效率，因为它不再需要估算堆是否需要调整大小了。</p>\n<h3 id=\"代空间的调整\"><a href=\"#代空间的调整\" class=\"headerlink\" title=\"代空间的调整\"></a>代空间的调整</h3><p>一旦堆的大小确定下来，jvm就需要决定分配多少堆给新生代空间，多少给老年代空间。如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少，老年代相对比较小，比较容易被填满，会更频繁地触发Full GC。<br>不同的GC算法尝试使用不同的方法来解决这些平衡问题。虽然方法不同，不过所有的GC方法都使用了同一套标志来设置代的大小<br>所有用于调整代空间的命令行标志调整的都是新生代空间，新生代空间剩下的所有空间都被老年代占用</p>\n<blockquote>\n<p>-XX:NewRatio=N 设置新生代与老年代的空间占用比率。<strong>初始新生代大小 = 初始堆大小 / (1 + NewRatio)</strong></p>\n<p>-XX:NewSize=N 设置新生代空间的初始大小</p>\n<p>-XX:MaxNewSize=N 设置新生代空间的最大大小</p>\n<p>-XmnN 将NewSize和MaxNewSize设定为同一个值的快捷方法</p>\n</blockquote>\n<h3 id=\"永久代和元空间的调整\"><a href=\"#永久代和元空间的调整\" class=\"headerlink\" title=\"永久代和元空间的调整\"></a>永久代和元空间的调整</h3><p>jvm载入类的时候，需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在Java 8称为元空间(Metaspace)，Java 8之前称为永久代<br>永久代和元空间并不完全一样。永久代保存了一些与数据无关的杂项对象，这些对象在Java 8中移到了普通的堆空间内。除此之外，Java 8从根本上改变了保存在这个特殊区域内的元数据类型。使用元空间替换掉永久代的优势之一时不再需要对其进行调整</p>\n<h3 id=\"控制并发\"><a href=\"#控制并发\" class=\"headerlink\" title=\"控制并发\"></a>控制并发</h3><p>除Serial收集器之外几乎所有的垃圾收集器使用的算法都基于多线程。启动的线程数由-XX:ParallelGCThreads=N参数控制<br>几乎所有的垃圾收集算法中基本的垃圾回收线程数都依据机器上的CPU数目计算得出，多个jvm运行于同一台物理机上时，计算得出的线程数可能过高，需进行优化</p>\n<h3 id=\"垃圾回收工具\"><a href=\"#垃圾回收工具\" class=\"headerlink\" title=\"垃圾回收工具\"></a>垃圾回收工具</h3><p>多开启GC日志，使用-verbose:gc或-XX:+PrintGC这两个标志中的任意一个能创建基本的GC日志。使用-XX:+PringGCDetails标志会创建更详细的GC日志，使用-XX:+PrintGCTimeStamps或-XX:PrintGCDateStamps，便于更精确地判断GC操作之间的时间，使用-Xloggc:filename标志修改输出到某个文件，使用日志循环标志可以限制保存在GC日志中的数据量。通过-XX:+UseGCLogfileRotaion -XX:NumberOfGCLogFiles=N -XX:GCLogfilesSize=N标志控制日志文件的循环<br><a href=\"https://github.com/jewes/gchisto\" target=\"_blank\" rel=\"external\">GC Histogram</a>能够读入GC日志，根据日志文件中的数据生成对应的图表和表格。<br>使用jconsole可以实时监控堆的使用情况<br>使用jstat监控应用程序的垃圾回收过程<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jstat -gcutil 28833 1000</div><div class=\"line\">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </div><div class=\"line\"> 66.63   0.00  65.51  46.64  94.45  91.38    330   27.059    12    0.859   27.918</div><div class=\"line\"> 66.63   0.00  65.60  46.64  94.45  91.38    330   27.059    12    0.859   27.918</div><div class=\"line\"> 66.63   0.00  65.60  46.64  94.45  91.38    330   27.059    12    0.859   27.918</div><div class=\"line\"> 66.63   0.00  65.60  46.64  94.45  91.38    330   27.059    12    0.859   27.918</div><div class=\"line\"> 66.63   0.00  65.63  46.64  94.45  91.38    330   27.059    12    0.859   27.918</div></pre></td></tr></table></figure></p>\n","tags":[]},{"title":"jit编译器","date":"2017-12-04T02:27:09.000Z","path":"2017/12/04/jit编译器/","text":"jit编译器JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。 在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel的Pentium微处理器或IBM的System/390处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。 热点编译对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行的越多就被认为是越热。因此jvm执行代码时，并不会立即编译代码。有两个基本理由。 如果代码只执行一次，那编译完全就是浪费精力，对于只执行一次的代码，解释执行字节码比先编译然后执行的速度快。但如果代码是经常被调用的方法，或者是运行很多次迭代的循环，编译就值得了。编译的代码更快，多次执行累计节约的时间超过了编译所话费的时间。这种权衡是编译器先解释执行代码的原因之一。编译器可以找出哪个方法被调用得足够频繁，可以进行编译。 jvm执行特定方法或者循环的次数越多，它就会越了解这段代码。这使得jvm可以在编译代码时进行大量优化。 代码缓存jvm编译代码时，会在代码缓存中保留编译之后的汇编语言指令集。代码缓存的大小固定，所以一旦填满，jvm就不能编译更多代码了。如果代码缓存过小，就可能会有一些热点被变异了，儿其他则没有。代码缓存填满时，jvm会发出以下警告 Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled. -XX:ReservedCodeCacheSize=N标志可以设置代码缓存的最大值 使用jconsole memory(内存)面板的Memory Pool(内存池) Code Cache图表，可以监控代码缓存 编译阀值代码执行的频度是触发代码编译最主要的因素。一旦执行达到一定次数，且达到了编译阀值，编译器就可以获得足够的信息编译代码了。编译是基于两种jvm计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。jvm执行某个java方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合，该方法就进入编译队列。 检测编译过程如果开启PrintCompilation(-XX:+PrintCompilation)，每次编译一个方法或循环时，jvm就会打印一行被编译的内容信息。编译日志需要在程序启动时开启PrintCompilation，如果程序启动时没有开启这个标志，可以使用jstat了解编译器内部的部分工作情况123$ jstat -compiler 8844Compiled Failed Invalid Time FailedType FailedMethod 28695 4 0 88.39 1 com/intellij/openapi/vfs/newvfs/impl/VirtualDirectoryImpl a","content":"<h1 id=\"jit编译器\"><a href=\"#jit编译器\" class=\"headerlink\" title=\"jit编译器\"></a>jit编译器</h1><p>JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。</p>\n<blockquote>\n<p>在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码（比如，Intel的Pentium微处理器或IBM的System/390处理器）。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。</p>\n</blockquote>\n<h3 id=\"热点编译\"><a href=\"#热点编译\" class=\"headerlink\" title=\"热点编译\"></a>热点编译</h3><p>对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行的越多就被认为是越热。<br>因此jvm执行代码时，并不会立即编译代码。有两个基本理由。</p>\n<ol>\n<li>如果代码只执行一次，那编译完全就是浪费精力，对于只执行一次的代码，解释执行字节码比先编译然后执行的速度快。但如果代码是经常被调用的方法，或者是运行很多次迭代的循环，编译就值得了。编译的代码更快，多次执行累计节约的时间超过了编译所话费的时间。这种权衡是编译器先解释执行代码的原因之一。编译器可以找出哪个方法被调用得足够频繁，可以进行编译。</li>\n<li>jvm执行特定方法或者循环的次数越多，它就会越了解这段代码。这使得jvm可以在编译代码时进行大量优化。</li>\n</ol>\n<h3 id=\"代码缓存\"><a href=\"#代码缓存\" class=\"headerlink\" title=\"代码缓存\"></a>代码缓存</h3><p>jvm编译代码时，会在代码缓存中保留编译之后的汇编语言指令集。代码缓存的大小固定，所以一旦填满，jvm就不能编译更多代码了。<br>如果代码缓存过小，就可能会有一些热点被变异了，儿其他则没有。代码缓存填满时，jvm会发出以下警告</p>\n<blockquote>\n<p>Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.</p>\n<p>-XX:ReservedCodeCacheSize=N标志可以设置代码缓存的最大值</p>\n</blockquote>\n<p>使用jconsole memory(内存)面板的Memory Pool(内存池) Code Cache图表，可以监控代码缓存</p>\n<h3 id=\"编译阀值\"><a href=\"#编译阀值\" class=\"headerlink\" title=\"编译阀值\"></a>编译阀值</h3><p>代码执行的频度是触发代码编译最主要的因素。一旦执行达到一定次数，且达到了编译阀值，编译器就可以获得足够的信息编译代码了。<br>编译是基于两种jvm计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。<br>jvm执行某个java方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合，该方法就进入编译队列。</p>\n<h3 id=\"检测编译过程\"><a href=\"#检测编译过程\" class=\"headerlink\" title=\"检测编译过程\"></a>检测编译过程</h3><p>如果开启PrintCompilation(-XX:+PrintCompilation)，每次编译一个方法或循环时，jvm就会打印一行被编译的内容信息。<br>编译日志需要在程序启动时开启PrintCompilation，如果程序启动时没有开启这个标志，可以使用jstat了解编译器内部的部分工作情况<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jstat -compiler 8844</div><div class=\"line\">Compiled Failed Invalid   Time   FailedType FailedMethod</div><div class=\"line\">   28695      4       0    88.39          1 com/intellij/openapi/vfs/newvfs/impl/VirtualDirectoryImpl a</div></pre></td></tr></table></figure></p>\n","tags":[{"name":"java jit","slug":"java-jit","permalink":"http://tanwenhai.github.com/tags/java-jit/"}]},{"title":"java 监控工具","date":"2017-12-02T06:44:51.000Z","path":"2017/12/02/java-监控工具/","text":"jcmd 用来打印java进程所涉及的基本类、线程、和VM信息 jconsole 提供jvm活动的图形化视图，包括线程的使用、类的使用和GC活动。 jhat 读取内存对转储 jmap 提供堆转储和其他内存使用信息 jinfo 查看jvm的系统属性，可以动态设置一些系统属性 jstack 转储java进程的栈信息 jstat 提供gc和类状态活动的信息 jvisualvm 监视jvm的gui工具，可视化GC、实现线程、堆内存。具有插件功能 基本的vm信息 获取jvm运行时长 jcmd process_id VM.uptime 获取系统属性 jcmd process_id VM.system_properties 获取jvm版本 jcmd process_id VM.version 获取jvm命令行 jcmd process_id VM.command_line 获取jvm调优标记,现实命令行设置的标记一级jvm直接设置的标志，加上-all时列出jvm内部所有的标志 jcmd process_id VM.flags [-all] 线程信息 jconsole和jvisualvm可以实时显示应用中运行中的线程数量 jstack 显示线程的栈信息 jstack process_id jcmd process_id Thread.print 类信息 jconsole或jstat可以提供应用已使用类的个数。jstat还能提供类编译相关的信息 实时gc分析几乎所有的监控工具都能报告一些gc活动的信息，jconsole可以用实时图显示堆的使用情况，jcmd可以执行gc操作，jmap可以打印堆的概括、永久带信息获取创建堆转储，jstat可以为垃圾收集器正在执行的操作生成许多视图 事后堆转储jvisualvm的gui界面可以捕获堆转储，也可以用命令行jcmd或jmap生成。堆转储是堆使用情况的快照，可以用不同的工具进行分析，包括jvisualvm和jhat","content":"<ol>\n<li>jcmd 用来打印java进程所涉及的基本类、线程、和VM信息</li>\n<li>jconsole 提供jvm活动的图形化视图，包括线程的使用、类的使用和GC活动。</li>\n<li>jhat 读取内存对转储</li>\n<li>jmap 提供堆转储和其他内存使用信息</li>\n<li>jinfo 查看jvm的系统属性，可以动态设置一些系统属性</li>\n<li>jstack 转储java进程的栈信息</li>\n<li>jstat 提供gc和类状态活动的信息</li>\n<li>jvisualvm 监视jvm的gui工具，可视化GC、实现线程、堆内存。具有插件功能</li>\n</ol>\n<h2 id=\"基本的vm信息\"><a href=\"#基本的vm信息\" class=\"headerlink\" title=\"基本的vm信息\"></a>基本的vm信息</h2><ol>\n<li><p>获取jvm运行时长</p>\n<pre><code>jcmd process_id VM.uptime\n</code></pre></li>\n</ol>\n<ol>\n<li><p>获取系统属性</p>\n<pre><code>jcmd process_id VM.system_properties\n</code></pre></li>\n<li><p>获取jvm版本</p>\n<pre><code>jcmd process_id VM.version\n</code></pre></li>\n<li><p>获取jvm命令行</p>\n<pre><code>jcmd process_id VM.command_line\n</code></pre></li>\n<li><p>获取jvm调优标记,现实命令行设置的标记一级jvm直接设置的标志，加上-all时列出jvm内部所有的标志</p>\n<pre><code>jcmd process_id VM.flags [-all]\n</code></pre></li>\n</ol>\n<h2 id=\"线程信息\"><a href=\"#线程信息\" class=\"headerlink\" title=\"线程信息\"></a>线程信息</h2><ol>\n<li><p>jconsole和jvisualvm可以实时显示应用中运行中的线程数量</p>\n</li>\n<li><p>jstack 显示线程的栈信息</p>\n<pre><code>jstack process_id\njcmd process_id Thread.print\n</code></pre></li>\n</ol>\n<h1 id=\"类信息\"><a href=\"#类信息\" class=\"headerlink\" title=\"类信息\"></a>类信息</h1><ol>\n<li>jconsole或jstat可以提供应用已使用类的个数。jstat还能提供类编译相关的信息</li>\n</ol>\n<h2 id=\"实时gc分析\"><a href=\"#实时gc分析\" class=\"headerlink\" title=\"实时gc分析\"></a>实时gc分析</h2><p>几乎所有的监控工具都能报告一些gc活动的信息，jconsole可以用实时图显示堆的使用情况，jcmd可以执行gc操作，jmap可以打印堆的概括、永久带信息获取创建堆转储，jstat可以为垃圾收集器正在执行的操作生成许多视图</p>\n<h2 id=\"事后堆转储\"><a href=\"#事后堆转储\" class=\"headerlink\" title=\"事后堆转储\"></a>事后堆转储</h2><p>jvisualvm的gui界面可以捕获堆转储，也可以用命令行jcmd或jmap生成。堆转储是堆使用情况的快照，可以用不同的工具进行分析，包括jvisualvm和jhat</p>\n","tags":[]},{"title":"spring cloud","date":"2017-11-25T02:00:24.000Z","path":"2017/11/25/spring-cloud/","text":"Spring Cloud是什么Spring Cloud是快速构建分布式系统的工具集(配置管理，服务发现，断路器，智能路由，全局锁，分布式会话…) 服务提供者/消费者 名词 概念 服务提供者 服务的被调用方(为其他的服务提供服务) 服务消费者 服务的调用方(依赖其他服务的服务)","content":"<h1 id=\"Spring-Cloud是什么\"><a href=\"#Spring-Cloud是什么\" class=\"headerlink\" title=\"Spring Cloud是什么\"></a>Spring Cloud是什么</h1><p>Spring Cloud是快速构建分布式系统的工具集(配置管理，服务发现，断路器，智能路由，全局锁，分布式会话…)</p>\n<h2 id=\"服务提供者-消费者\"><a href=\"#服务提供者-消费者\" class=\"headerlink\" title=\"服务提供者/消费者\"></a>服务提供者/消费者</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名词</th>\n<th style=\"text-align:left\">概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">服务提供者</td>\n<td style=\"text-align:left\">服务的被调用方(为其他的服务提供服务)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">服务消费者</td>\n<td style=\"text-align:left\">服务的调用方(依赖其他服务的服务)</td>\n</tr>\n</tbody>\n</table>\n<hr>\n","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://tanwenhai.github.com/tags/spring-cloud/"}]},{"title":"docker","date":"2017-11-11T12:57:35.000Z","path":"2017/11/11/docker/","text":"容器运行容器1docker run -itd twh/java 查看容器1docker ps -a 删除容器1docker rm $(docker container ls -a -q) 连接后台运行中的容器1docker attach twh/java 该命令有时候不方便，因为是同步的，若有多个用户attach到一个容器，一个窗口命令阻塞，其他窗口都无法执行 1docker exec -it twh/java 导出容器1docker export 容器ID &gt; java.tar.gz 镜像查找镜像1docker search mysql -s 100 拉取镜像1docker pull mysql 删除镜像1docker rmi 镜像ID 保存镜像1docker save -o java.tar.gz twh/java 导入镜像1cat java.tar.gz|docker import - twh/java:v1.0.1 docker 私有仓库搭建 获取registry镜像 1docker pull registry 运行镜像 -p端口映射 -v数据卷 1docker run -d -p 5000:5000 -v /data/docker/registry:/tmp/registry registry 上传镜像 1docker push 192.168.3.3:5000/java 容器互联 要实现容器互联，需要为容器指定一个方便记忆的名字，通过–name来指定 1docker run -d -it --name test1 gitlab/gitlab-ce 启动容器 1docker run -itd --name mysql -v /data/docker/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql 连接容器 –link 容器名:别名 1docker run -d -it --name test1 --link mysql:mysql gitlab/gitlab-ce 查看hosts和环境变量 1cat /etc/hosts Dockerfile 基础镜像信息 12345678910111213# 这里注释# 第一行必须指定基础镜像可以多个FROM centos # 维护者信息MAINTAINER tanwenhai tanwenhai@outlok.com# 镜像操作指令VOLUME /tmpADD demo-0.0.1-SNAPSHOT.jar jarENV JAVA_OPTS \"\"RUN yum -y install mysqlEXPOSE 8080:8080# 容器启动指令CMD [\"sh\", \"-c\", \"java $JAVA_OPTS -jar app.jar\"] 语法 FROM 指定基础镜像 格式为FROM image或FROM image:tag MAINTAINER 维护者信息 MAINTAINER 用户名 邮箱 RUN 镜像操作 run指令在build具有缓存 RUN command 或RUN [“EXECUTABLE”, “param1”…] 后者使用exec运行 CMD 启动命令 多个CMD命令只执行最后一个 CMD 或RUN [“EXECUTABLE”, “param1”…] 使用exec运行 CMD command param1 … CMD [“param1”, …] 提供给ENTERYPOINT的默认参数 EXPOSE 暴露端口 EXPOSE port [port/protocol…] ENV 环境变量 ENV key value ENV key=value … ADD 复制本地目录中的文件到容器中的dest ADD src dest COPY 和ADD一样 dest不存在是会自动创建目录 COPY src dest ENTRYPOINT 容器启动后执行的命令 ENTRYPOINT [“executable”, “param1”, …] volume 创建数据卷 VOLUME [“/data”] USER 指定容器运行时的用户名或UID USER username WORKDIR 为后续的RUN、CMD、ENTRYPOINT指定配置工作目录 WORKDIR /APP 构建镜像 -t 指定奖项的标签信息 用&amp;&amp;连接命令可以减少镜像大小 docker build -t centos_test . NetWork 创建网络 1docker network create test_netework 查看网络信息 1docker network inspect test_network 删除网络 1docker network rm test_network 容器使用指定网络 –net 1docker run -itd --net=test_network centos 连接容器 网络中所有主机除ip访问外，还可以直接用容器名(container-name)作为hostname相互访问 1docker network connect test_network mysql 移除网络 1docker network disconnet test_network mysql","content":"<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><h3 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -itd twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker ps -a</div></pre></td></tr></table></figure>\n<h3 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker rm $(docker container ls -a -q)</div></pre></td></tr></table></figure>\n<h3 id=\"连接后台运行中的容器\"><a href=\"#连接后台运行中的容器\" class=\"headerlink\" title=\"连接后台运行中的容器\"></a>连接后台运行中的容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker attach twh/java</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>该命令有时候不方便，因为是同步的，若有多个用户attach到一个容器，一个窗口命令阻塞，其他窗口都无法执行</strong></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker <span class=\"built_in\">exec</span> -it twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker <span class=\"built_in\">export</span> 容器ID &gt; java.tar.gz</div></pre></td></tr></table></figure>\n<h1 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h1><h3 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker search mysql -s 100</div></pre></td></tr></table></figure>\n<h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull mysql</div></pre></td></tr></table></figure>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker rmi 镜像ID</div></pre></td></tr></table></figure>\n<h3 id=\"保存镜像\"><a href=\"#保存镜像\" class=\"headerlink\" title=\"保存镜像\"></a>保存镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker save -o java.tar.gz twh/java</div></pre></td></tr></table></figure>\n<h3 id=\"导入镜像\"><a href=\"#导入镜像\" class=\"headerlink\" title=\"导入镜像\"></a>导入镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat java.tar.gz|docker import - twh/java:v1.0.1</div></pre></td></tr></table></figure>\n<h1 id=\"docker-私有仓库搭建\"><a href=\"#docker-私有仓库搭建\" class=\"headerlink\" title=\"docker 私有仓库搭建\"></a>docker 私有仓库搭建</h1><ol>\n<li><p>获取registry镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull registry</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行镜像 -p端口映射 -v数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -p 5000:5000 -v /data/docker/registry:/tmp/registry registry</div></pre></td></tr></table></figure>\n</li>\n<li><p>上传镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker push 192.168.3.3:5000/java</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h1><ol>\n<li><p>要实现容器互联，需要为容器指定一个方便记忆的名字，通过–name来指定</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -it --name test1 gitlab/gitlab-ce</div></pre></td></tr></table></figure>\n</li>\n<li><p>启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -itd --name mysql -v /data/docker/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql</div></pre></td></tr></table></figure>\n</li>\n<li><p>连接容器 –link 容器名:别名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -it --name test1 --link mysql:mysql gitlab/gitlab-ce</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看hosts和环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat /etc/hosts</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><ol>\n<li><p>基础镜像信息</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 这里注释</span></div><div class=\"line\"><span class=\"comment\"># 第一行必须指定基础镜像可以多个</span></div><div class=\"line\"><span class=\"keyword\">FROM</span> centos </div><div class=\"line\"><span class=\"comment\"># 维护者信息</span></div><div class=\"line\"><span class=\"keyword\">MAINTAINER</span> tanwenhai tanwenhai@outlok.com</div><div class=\"line\"><span class=\"comment\"># 镜像操作指令</span></div><div class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> /tmp</span></div><div class=\"line\"><span class=\"bash\">ADD demo-0.0.1-SNAPSHOT.jar jar</span></div><div class=\"line\"><span class=\"bash\">ENV JAVA_OPTS <span class=\"string\">\"\"</span></span></div><div class=\"line\"><span class=\"bash\">RUN yum -y install mysql</span></div><div class=\"line\"><span class=\"bash\">EXPOSE 8080:8080</span></div><div class=\"line\"><span class=\"bash\"><span class=\"comment\"># 容器启动指令</span></span></div><div class=\"line\"><span class=\"bash\">CMD [<span class=\"string\">\"sh\"</span>, <span class=\"string\">\"-c\"</span>, <span class=\"string\">\"java <span class=\"variable\">$JAVA_OPTS</span> -jar app.jar\"</span>]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>语法</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>FROM</strong> 指定基础镜像</p>\n<blockquote>\n<p>格式为FROM image或FROM image:tag</p>\n</blockquote>\n</li>\n<li><p><strong>MAINTAINER</strong> 维护者信息</p>\n<blockquote>\n<p>MAINTAINER 用户名 邮箱</p>\n</blockquote>\n</li>\n<li><p><strong>RUN</strong> 镜像操作</p>\n<p>  <em>run指令在build具有缓存</em></p>\n<blockquote>\n<p>RUN command 或RUN [“EXECUTABLE”, “param1”…] 后者使用exec运行</p>\n</blockquote>\n</li>\n<li><p><strong>CMD</strong> 启动命令</p>\n<p>  <em>多个CMD命令只执行最后一个</em></p>\n<blockquote>\n<p>CMD 或RUN [“EXECUTABLE”, “param1”…] 使用exec运行<br>  CMD command param1 …<br>  CMD [“param1”, …] 提供给ENTERYPOINT的默认参数</p>\n</blockquote>\n</li>\n<li><strong>EXPOSE</strong> 暴露端口<blockquote>\n<p>EXPOSE port [port/protocol…]</p>\n</blockquote>\n</li>\n<li><p><strong>ENV</strong> 环境变量</p>\n<blockquote>\n<p>ENV key value<br>  ENV key=value …</p>\n</blockquote>\n</li>\n<li><p><strong>ADD</strong> 复制本地目录中的文件到容器中的dest</p>\n<blockquote>\n<p>ADD src dest</p>\n</blockquote>\n</li>\n<li><p><strong>COPY</strong> 和ADD一样 dest不存在是会自动创建目录</p>\n<blockquote>\n<p>COPY src dest</p>\n</blockquote>\n</li>\n<li><p><strong>ENTRYPOINT</strong> 容器启动后执行的命令</p>\n<blockquote>\n<p>ENTRYPOINT [“executable”, “param1”, …] </p>\n</blockquote>\n</li>\n<li><p><strong>volume</strong> 创建数据卷</p>\n<blockquote>\n<p>VOLUME [“/data”]</p>\n</blockquote>\n</li>\n<li><p><strong>USER</strong> 指定容器运行时的用户名或UID</p>\n<blockquote>\n<p>USER username</p>\n</blockquote>\n</li>\n<li><p><strong>WORKDIR</strong> 为后续的RUN、CMD、ENTRYPOINT指定配置工作目录</p>\n<blockquote>\n<p>WORKDIR /APP</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p>构建镜像 </p>\n<p> <em>-t 指定奖项的标签信息</em> 用&amp;&amp;连接命令可以减少镜像大小</p>\n<blockquote>\n<p>docker build -t centos_test .</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"NetWork\"><a href=\"#NetWork\" class=\"headerlink\" title=\"NetWork\"></a>NetWork</h1><ol>\n<li><p>创建网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker network create test_netework</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看网络信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker network inspect test_network</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker network rm test_network</div></pre></td></tr></table></figure>\n</li>\n<li><p>容器使用指定网络 <em>–net</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -itd --net=test_network centos</div></pre></td></tr></table></figure>\n</li>\n<li><p>连接容器 网络中所有主机除ip访问外，还可以直接用容器名(container-name)作为hostname相互访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker network connect test_network mysql</div></pre></td></tr></table></figure>\n</li>\n<li><p>移除网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker network disconnet test_network mysql</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","tags":[{"name":"docker","slug":"docker","permalink":"http://tanwenhai.github.com/tags/docker/"}]},{"title":"jinfo:JAVA进程运行时修改虚拟机参数利器（无需重启）","date":"2017-11-11T09:00:50.000Z","path":"2017/11/11/jinfo/","text":"转 http://www.open-open.com/lib/view/open1437018491912.html 虚拟机总会有出现问题的时候，并且你深深的知道如果通过配置一些参数使得虚拟机打印一些运行时信息，可以通过这种途径改善虚拟机的运行状况。如 XX:+HeapDumpOnOutOfMemoryError和XX:+PrintGCDetails。但是有时候这些参数会丢失，这是件令人头痛的事情。因此，你痛苦的耸了耸肩，杀掉虚拟机进程，修改启动参数并祈祷之前的糟糕状况可以在重新启动之后重现。现在你拥有足够的证据来查找问题的根源，并改正。前面描述的方式，很显然需要一次额外的重启并添加一些调试参数。实际上，不需要重启虚拟机的方法是有的，这种方法好处是大大的。JDK打包工具里面为我们提供了一个很好的小工具。jinfo是一个命令行工具，通过这个工具可以获取JAVA进程运行时的一些信息，通过使用jinfo 和一些参数，可以动态修改JAVA进程的虚拟机参数，这些参数并不是万能的，但是在一些场景中是非常有用的。虚拟机的这些参数可以通过下面的命令查看：12345678910111213141516171819202122$ java -XX:+PrintFlagsFinal -version| grep manageable intx CMSAbortablePrecleanWaitMillis = 100 &#123;manageable&#125; intx CMSTriggerInterval = -1 &#123;manageable&#125; intx CMSWaitDuration = 2000 &#123;manageable&#125; bool HeapDumpAfterFullGC = false &#123;manageable&#125; bool HeapDumpBeforeFullGC = false &#123;manageable&#125; bool HeapDumpOnOutOfMemoryError = false &#123;manageable&#125; ccstr HeapDumpPath = &#123;manageable&#125; uintx MaxHeapFreeRatio = 100 &#123;manageable&#125; uintx MinHeapFreeRatio = 0 &#123;manageable&#125; bool PrintClassHistogram = false &#123;manageable&#125; bool PrintClassHistogramAfterFullGC = false &#123;manageable&#125; bool PrintClassHistogramBeforeFullGC = false &#123;manageable&#125; bool PrintConcurrentLocks = false &#123;manageable&#125; bool PrintGC = false &#123;manageable&#125; bool PrintGCDateStamps = false &#123;manageable&#125; bool PrintGCDetails = false &#123;manageable&#125; bool PrintGCID = false &#123;manageable&#125; bool PrintGCTimeStamps = false &#123;manageable&#125;java version \"1.8.0_112\"Java(TM) SE Runtime Environment (build 1.8.0_112-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode) 我们通过-XX:+PrintFlagsFinal -version参数可以获取JVM的所有选项，然而manageable才是我们所感兴趣的，通过JDK的管理接口（com.sun.management.HotSpotDiagnosticMCBean API）可以动态写入。非常相似的MBean也可以通过Jconsole查看，对于我来说命令行的方式是非常方便的。下面是一个使用jinfo的例子：我们通过动态打开JVM的GC日志开关例子来演示jinfo如何使用。我们先通过jps来查看当前运行状态的虚拟机进程：123$ jps -l31907 app.jar5574 sun.tools.jps.Jps 我们通过使用jinfo来打开虚拟机GC日志打印参数，-XX:+PrintGC和-XX:+PrintGCDetails。使用命令行方式微小的差别在于需要为jinfo同时指定-XX:+PrintGC和-XX:+PrintGCDetails参数。除了通过启动脚本可以设置参数，PrintGC默认是打开的，因此我们只需要打开PrintGCDetails参数。12$ jinfo -flag +PrintGCDDetails 31907$ jinfo -flag +PrintGC 31907","content":"<blockquote>\n<p>转 <a href=\"http://www.open-open.com/lib/view/open1437018491912.html\" target=\"_blank\" rel=\"external\">http://www.open-open.com/lib/view/open1437018491912.html</a></p>\n</blockquote>\n<p>虚拟机总会有出现问题的时候，并且你深深的知道如果通过配置一些参数使得虚拟机打印一些运行时信息，可以通过这种途径改善虚拟机的运行状况。如 XX:+HeapDumpOnOutOfMemoryError和XX:+PrintGCDetails。但是有时候这些参数会丢失，这是件令人头痛的事情。<br>因此，你痛苦的耸了耸肩，杀掉虚拟机进程，修改启动参数并祈祷之前的糟糕状况可以在重新启动之后重现。现在你拥有足够的证据来查找问题的根源，并改正。前面描述的方式，很显然需要一次额外的重启并添加一些调试参数。实际上，不需要重启虚拟机的方法是有的，这种方法好处是大大的。<br>JDK打包工具里面为我们提供了一个很好的小工具。jinfo是一个命令行工具，通过这个工具可以获取JAVA进程运行时的一些信息，通过使用jinfo 和一些参数，可以动态修改JAVA进程的虚拟机参数，这些参数并不是万能的，但是在一些场景中是非常有用的。虚拟机的这些参数可以通过下面的命令查看：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ java -XX:+PrintFlagsFinal -version| grep manageable</div><div class=\"line\">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;</div><div class=\"line\">     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;</div><div class=\"line\">     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpAfterFullGC                       = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpBeforeFullGC                      = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool HeapDumpOnOutOfMemoryError                = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;</div><div class=\"line\">    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;</div><div class=\"line\">    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogram                       = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogramAfterFullGC            = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintClassHistogramBeforeFullGC           = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintConcurrentLocks                      = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGC                                   = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCDateStamps                         = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCDetails                            = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCID                                 = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">     bool PrintGCTimeStamps                         = <span class=\"literal\">false</span>                               &#123;manageable&#125;</div><div class=\"line\">java version <span class=\"string\">\"1.8.0_112\"</span></div><div class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</div><div class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</div></pre></td></tr></table></figure></p>\n<p>我们通过-XX:+PrintFlagsFinal -version参数可以获取JVM的所有选项，然而manageable才是我们所感兴趣的，通过JDK的管理接口（com.sun.management.HotSpotDiagnosticMCBean API）可以动态写入。非常相似的MBean也可以通过Jconsole查看，对于我来说命令行的方式是非常方便的。<br>下面是一个使用jinfo的例子：<br>我们通过动态打开JVM的GC日志开关例子来演示jinfo如何使用。<br>我们先通过jps来查看当前运行状态的虚拟机进程：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jps -l</div><div class=\"line\">31907 app.jar</div><div class=\"line\">5574 sun.tools.jps.Jps</div></pre></td></tr></table></figure></p>\n<p>我们通过使用jinfo来打开虚拟机GC日志打印参数，-XX:+PrintGC和-XX:+PrintGCDetails。使用命令行方式微小的差别在于需要为jinfo同时指定-XX:+PrintGC和-XX:+PrintGCDetails参数。除了通过启动脚本可以设置参数，PrintGC默认是打开的，因此我们只需要打开PrintGCDetails参数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ jinfo -flag +PrintGCDDetails 31907</div><div class=\"line\">$ jinfo -flag +PrintGC 31907</div></pre></td></tr></table></figure></p>\n","tags":[{"name":"linux jinfo","slug":"linux-jinfo","permalink":"http://tanwenhai.github.com/tags/linux-jinfo/"}]},{"title":"微服务和单体应用对比","date":"2017-11-06T13:38:46.000Z","path":"2017/11/06/微服务和单体应用对比/","text":"单体应用容易部署、测试随功能演进越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高 复杂性高 技术债务 可靠性差 扩展能力受限 阻碍技术创新 微服务具有以下优点 易于开发和维护 单个微服务启动较快 局部修改容易部署 技术栈不受限 按需伸缩","content":"<blockquote>\n<p>单体应用容易部署、测试随功能演进越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高</p>\n</blockquote>\n<ol>\n<li>复杂性高</li>\n<li>技术债务</li>\n<li>可靠性差</li>\n<li>扩展能力受限</li>\n<li>阻碍技术创新</li>\n</ol>\n<blockquote>\n<p>微服务具有以下优点</p>\n</blockquote>\n<ol>\n<li>易于开发和维护</li>\n<li>单个微服务启动较快</li>\n<li>局部修改容易部署</li>\n<li>技术栈不受限</li>\n<li>按需伸缩</li>\n</ol>\n","tags":[]},{"title":"linux iostat","date":"2017-11-06T07:24:38.000Z","path":"2017/11/06/linux-iostat/","text":"简介 iostat主要用于监控系统设备的IO负载情况，iostat首次运行时显示自系统启动开始的各项统计信息，之后运行iostat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。 -d 显示设备（磁盘）使用状态 -k 指定iostat的部分输出结果以kB为单位，而不是以扇区数为单位 -c 显示更详细的io设备统计信息1234567891011121314151617$ iostat -dkx 1 5Linux 2.6.32-696.1.1.el6.x86_64 (iZuf650me9vkz4vfzq4htwZ) 11/06/2017 _x86_64_ (4 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.02 26.90 0.28 1.23 10.82 112.50 164.15 0.08 53.10 6.34 63.66 1.95 0.29Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 2.00 0.00 2.00 0.00 16.00 16.00 0.00 1.00 0.00 1.00 1.00 0.20Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 rrqm/s 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并 wrqm/s 每秒对该设备的写请求被合并次数 r/s 每秒完成的读取次数 w/s 每秒完成的写次数 rkB/s 每秒读数据量(kB为单位) wkB/s 每秒写数据量(kB为单位) avgrq-sz 平均每次IO操作的数据量(扇区数为单位) avgqu-sz 平均等待处理的IO请求队列长度 await 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位) r_await 平均每次IO请求读等待时间 w_await 平均每次IO请求写等待时间 svctm 平均每次IO请求的处理时间(毫秒为单位) %util 采集周期内用于IO操作的时间比率，即IO队列非空的时间比率","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>iostat主要用于监控系统设备的IO负载情况，iostat首次运行时显示自系统启动开始的各项统计信息，之后运行iostat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。</p>\n</blockquote>\n<ol>\n<li><strong>-d</strong> 显示设备（磁盘）使用状态</li>\n<li><strong>-k</strong> 指定iostat的部分输出结果以kB为单位，而不是以扇区数为单位</li>\n<li><strong>-c</strong> 显示更详细的io设备统计信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ iostat -dkx 1 5</div><div class=\"line\">Linux 2.6.32-696.1.1.el6.x86_64 (iZuf650me9vkz4vfzq4htwZ) \t11/06/2017 \t_x86_64_\t(4 CPU)</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.02    26.90    0.28    1.23    10.82   112.50   164.15     0.08   53.10    6.34   63.66   1.95   0.29</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     2.00    0.00    2.00     0.00    16.00    16.00     0.00    1.00    0.00    1.00   1.00   0.20</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div><div class=\"line\"></div><div class=\"line\">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</div><div class=\"line\">vda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><strong>rrqm/s</strong> 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li>\n<li><strong>wrqm/s</strong> 每秒对该设备的写请求被合并次数</li>\n<li><strong>r/s</strong> 每秒完成的读取次数</li>\n<li><strong>w/s</strong> 每秒完成的写次数</li>\n<li><strong>rkB/s</strong> 每秒读数据量(kB为单位)</li>\n<li><strong>wkB/s</strong> 每秒写数据量(kB为单位)</li>\n<li><strong>avgrq-sz</strong> 平均每次IO操作的数据量(扇区数为单位)</li>\n<li><strong>avgqu-sz</strong> 平均等待处理的IO请求队列长度</li>\n<li><strong>await</strong> 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li>\n<li><strong>r_await</strong> 平均每次IO请求读等待时间</li>\n<li><strong>w_await</strong> 平均每次IO请求写等待时间</li>\n<li><strong>svctm</strong> 平均每次IO请求的处理时间(毫秒为单位)</li>\n<li><strong>%util</strong> 采集周期内用于IO操作的时间比率，即IO队列非空的时间比率</li>\n</ul>\n","tags":[{"name":"linux iostat","slug":"linux-iostat","permalink":"http://tanwenhai.github.com/tags/linux-iostat/"}]},{"title":"linux vmstat","date":"2017-11-06T06:44:23.000Z","path":"2017/11/06/linux-vmstat/","text":"vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如: 12345678910111213$ vmstat 1 10procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 129616 6552 1734536 0 0 3 28 0 0 2 0 97 0 0 0 0 0 129352 6552 1734636 0 0 0 172 1644 1196 4 1 96 0 0 0 0 0 129352 6552 1734668 0 0 0 0 1338 1164 3 1 97 0 0 1 0 0 129632 6552 1734932 0 0 0 0 2695 2396 14 1 85 0 0 1 0 0 128640 6560 1735324 0 0 0 16 2208 2082 11 1 88 0 0 0 0 0 128252 6560 1735692 0 0 0 0 1361 1024 7 1 92 0 0 0 0 0 128244 6560 1735756 0 0 0 16 854 831 2 1 97 0 0 1 0 0 128384 6560 1735828 0 0 0 0 1651 1289 4 1 95 0 0 0 0 0 128260 6560 1735872 0 0 0 0 1178 995 2 1 97 0 0 0 0 0 128260 6568 1735900 0 0 0 20 1086 958 2 0 98 0 0 第一个参数表示每隔多久采集一次 第二个参数是总共采集次数 r 表示运行队列 b 表示阻塞的进程 swpd 交换分区虚拟内存已使用的大小 free 空闲的物理内存的大小 buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存 cache cache直接用来记忆我们打开的文件,给文件做缓冲 si 每秒从磁盘读入虚拟内存(交换分区)的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了 so 每秒虚拟内存写入磁盘的大小(交换分区)，如果这个值大于0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 in 每秒CPU的中断次数，包括时间中断 cs 每秒上下文切换次数，调用系统函数、线程的切换需要进程上下文切换，这个值要越小越好 us 用户CPU时间(用户态) sy 系统CPU时间(系统态) id CPU空闲时间 一般来说，id + us + sy = 100 wa 等待IO CPU时间。 st 未知","content":"<p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。</p>\n<blockquote>\n<p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vmstat 1 10</span></div><div class=\"line\">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</div><div class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class=\"line\"> 0  0      0 129616   6552 1734536    0    0     3    28    0    0  2  0 97  0  0</div><div class=\"line\"> 0  0      0 129352   6552 1734636    0    0     0   172 1644 1196  4  1 96  0  0</div><div class=\"line\"> 0  0      0 129352   6552 1734668    0    0     0     0 1338 1164  3  1 97  0  0</div><div class=\"line\"> 1  0      0 129632   6552 1734932    0    0     0     0 2695 2396 14  1 85  0  0</div><div class=\"line\"> 1  0      0 128640   6560 1735324    0    0     0    16 2208 2082 11  1 88  0  0</div><div class=\"line\"> 0  0      0 128252   6560 1735692    0    0     0     0 1361 1024  7  1 92  0  0</div><div class=\"line\"> 0  0      0 128244   6560 1735756    0    0     0    16  854  831  2  1 97  0  0</div><div class=\"line\"> 1  0      0 128384   6560 1735828    0    0     0     0 1651 1289  4  1 95  0  0</div><div class=\"line\"> 0  0      0 128260   6560 1735872    0    0     0     0 1178  995  2  1 97  0  0</div><div class=\"line\"> 0  0      0 128260   6568 1735900    0    0     0    20 1086  958  2  0 98  0  0</div></pre></td></tr></table></figure>\n<blockquote>\n<p>第一个参数表示每隔多久采集一次 第二个参数是总共采集次数</p>\n<ul>\n<li><strong>r</strong> 表示运行队列</li>\n<li><strong>b</strong> 表示阻塞的进程</li>\n<li><strong>swpd</strong> 交换分区虚拟内存已使用的大小</li>\n<li><strong>free</strong> 空闲的物理内存的大小</li>\n<li><strong>buff</strong> Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存</li>\n<li><strong>cache</strong> cache直接用来记忆我们打开的文件,给文件做缓冲</li>\n<li><strong>si</strong> 每秒从磁盘读入虚拟内存(交换分区)的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了</li>\n<li><strong>so</strong> 每秒虚拟内存写入磁盘的大小(交换分区)，如果这个值大于0，同上。</li>\n<li><strong>bi</strong> 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte</li>\n<li><strong>bo</strong> 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</li>\n<li><strong>in</strong> 每秒CPU的中断次数，包括时间中断</li>\n<li><strong>cs</strong> 每秒上下文切换次数，调用系统函数、线程的切换需要进程上下文切换，这个值要越小越好</li>\n<li><strong>us</strong> 用户CPU时间(用户态)</li>\n<li><strong>sy</strong> 系统CPU时间(系统态)</li>\n<li><strong>id</strong> CPU空闲时间 一般来说，id + us + sy = 100</li>\n<li><strong>wa</strong> 等待IO CPU时间。</li>\n<li><strong>st</strong> 未知</li>\n</ul>\n</blockquote>\n","tags":[{"name":"linux vmstat","slug":"linux-vmstat","permalink":"http://tanwenhai.github.com/tags/linux-vmstat/"}]},{"title":"spring IoC容器的实现","date":"2017-11-01T06:58:31.000Z","path":"2017/11/01/spring-IoC容器的实现/","text":"IoC控制反转 依赖对象不由自身实现，由外部注入，在具体的注入实现中，接口注入、setter注入和构造器注入是主要的注入方式 对象生成或初始化时直接将数据注入到对象中 通过将对象引用注入到对象数据域中 在Spring IoC容器的设计中，有两个主要的容器系列，一个是实现BeanFactory接口的简单容器系列，另一个是ApplicationContext应用上下文，应用上下文在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配。 在这些Spring提供的基本IoC容器的接口定义和实现的基础上，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系，BeanDefinition抽象了对Bean的定义，对Ioc容器来说BeanDefinition就是对依赖反转模式中管理的对象依赖关系 IoC容器的初始化过程由AbstractApplicationContext#refresh开始,包括BeanDefinition载入、注入 第一个过程是Resource定位，Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resouce接口来完成 第二个过程是BeanDefinition的载入，载入过程是把用户定义的Bean表示成IoC容器内部的数据结构 第三个过程是向Ioc容器注册这些BeanDefinition的过程，通过调用BeanDefinitionRegistry接口的实现来完成","content":"<ol>\n<li>IoC控制反转 依赖对象不由自身实现，由外部注入，在具体的注入实现中，接口注入、setter注入和构造器注入是主要的注入方式<ul>\n<li>对象生成或初始化时直接将数据注入到对象中</li>\n<li>通过将对象引用注入到对象数据域中</li>\n</ul>\n</li>\n<li>在Spring IoC容器的设计中，有两个主要的容器系列，一个是实现BeanFactory接口的简单容器系列，另一个是ApplicationContext应用上下文，<strong>应用上下文在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境做了许多适配</strong>。<ul>\n<li><img src=\"/2017/11/01/spring-IoC容器的实现/BeanFactory.png\" alt=\"BeanFactory继承图\" title=\"BeanFactory继承图\"></li>\n<li>在这些Spring提供的基本IoC容器的接口定义和实现的基础上，Spring通过<strong>定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系</strong>，BeanDefinition抽象了对Bean的定义，对Ioc容器来说BeanDefinition就是对依赖反转模式中管理的对象依赖关系</li>\n<li><img src=\"/2017/11/01/spring-IoC容器的实现/IoC容器接口设计图.png\" alt=\"IoC容器接口设计图\" title=\"IoC容器接口设计图\"></li>\n</ul>\n</li>\n<li>IoC容器的初始化过程由<em>AbstractApplicationContext#refresh</em>开始,包括BeanDefinition载入、注入<ul>\n<li>第一个过程是Resource定位，Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resouce接口来完成</li>\n<li>第二个过程是BeanDefinition的载入，载入过程是把用户定义的Bean表示成IoC容器内部的数据结构</li>\n<li>第三个过程是向Ioc容器注册这些BeanDefinition的过程，通过调用BeanDefinitionRegistry接口的实现来完成</li>\n</ul>\n</li>\n</ol>\n","tags":[{"name":"spring","slug":"spring","permalink":"http://tanwenhai.github.com/tags/spring/"}]},{"title":"Hystrix","date":"2017-10-02T07:39:13.000Z","path":"2017/10/02/Hystrix/","text":"使用注解@EnableCircuitBreaker启用断路功能HystrixCommand: 用在依赖的服务返回单个操作结果的时候HystrixObservableCommand: 用在依赖的服务返回多个操作结果的时候","content":"<p>使用注解@EnableCircuitBreaker启用断路功能<br>HystrixCommand: 用在依赖的服务返回单个操作结果的时候<br>HystrixObservableCommand: 用在依赖的服务返回多个操作结果的时候</p>\n","tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://tanwenhai.github.com/tags/spring-cloud/"}]},{"title":"Ribbon","date":"2017-09-30T01:19:07.000Z","path":"2017/09/30/Ribbon/","text":"Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具通过@LoadBalancer给RestTemplate增加服务负载均衡支持 创建一个LoadBalancerInterceptor的Bean,用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡 创建了一个RestTemplateCustomizer的Bean,用于给RestTemplate增加LoadBalancerInterceptor拦截器 维护了一个被@LoadBalanced注解修饰的RestTemplate对象列表，并初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载均衡的RestTemplate增加LoadBalancerInterceptor拦截器","content":"<p>Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具<br>通过@LoadBalancer给RestTemplate增加服务负载均衡支持</p>\n<ol>\n<li>创建一个LoadBalancerInterceptor的Bean,用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡</li>\n<li>创建了一个RestTemplateCustomizer的Bean,用于给RestTemplate增加LoadBalancerInterceptor拦截器</li>\n<li>维护了一个被@LoadBalanced注解修饰的RestTemplate对象列表，并初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载均衡的RestTemplate增加LoadBalancerInterceptor拦截器</li>\n</ol>\n","tags":[{"name":"Spring Cloud Ribbon","slug":"Spring-Cloud-Ribbon","permalink":"http://tanwenhai.github.com/tags/Spring-Cloud-Ribbon/"}]},{"title":"nginx location指令","date":"2017-02-14T07:50:11.000Z","path":"2017/02/14/nginx-location指令/","text":"12345678910111213141516171819location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; configuration A 精确匹配 path=/ configuration B 匹配 path=/* 如 /index.html configuration C 匹配 path=/documents/* 如 /documents/document.html configuration D 正则唯一匹配 path=/images/* 如 /images/1.gif configuration E 正则不区分大小写匹配 *.(gif|jpg|jpeg) 如 /documents/1.jpg","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">location = / &#123;</div><div class=\"line\">    [ configuration A ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location / &#123;</div><div class=\"line\">    [ configuration B ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location /documents/ &#123;</div><div class=\"line\">    [ configuration C ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location ^~ /images/ &#123;</div><div class=\"line\">    [ configuration D ]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">location ~* \\.(gif|jpg|jpeg)$ &#123;</div><div class=\"line\">    [ configuration E ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>configuration A 精确匹配 path=/</li>\n<li>configuration B 匹配 path=/* 如 /index.html</li>\n<li>configuration C 匹配 path=/documents/* 如 /documents/document.html</li>\n<li>configuration D 正则唯一匹配 path=/images/* 如 /images/1.gif</li>\n<li>configuration E 正则不区分大小写匹配 *.(gif|jpg|jpeg) 如 /documents/1.jpg</li>\n</ul>\n","tags":[{"name":"nginx","slug":"nginx","permalink":"http://tanwenhai.github.com/tags/nginx/"}]},{"title":"使用dblib连接sybase","date":"2017-02-14T07:17:14.000Z","path":"2017/02/14/使用dblib连接sybase/","text":"安装freetds 1yum install freetds freetds-dev 安装pdo_dblib扩展 12pecl install pdo_dblibphp --ri pdo_dblib # 验证扩展是否安装 pdo连接 12345678$dsn = 'dblib:appname=PHP freetds;host=localhost:12345;dbname=abc';$user = 'username';$passwd = 'password';try &#123; $dbh = new \\PDO($dsn, $user, $passwd);&#125; catch(\\PDOException $e) &#123; echo $e -&gt;getMessage();&#125; *yum源没有freetds123wget http://www6.atomicorp.com/channels/atomic/centos/7/x86_64/RPMS/atomic-release*rpmrpm -Uvh atomic-release*rpmyum install freetds","content":"<ol>\n<li><p>安装freetds</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install freetds freetds-dev</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装pdo_dblib扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pecl install pdo_dblib</div><div class=\"line\">php --ri pdo_dblib <span class=\"comment\"># 验证扩展是否安装</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>pdo连接</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$dsn = <span class=\"string\">'dblib:appname=PHP freetds;host=localhost:12345;dbname=abc'</span>;</div><div class=\"line\">$user = <span class=\"string\">'username'</span>;</div><div class=\"line\">$passwd = <span class=\"string\">'password'</span>;</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    $dbh = <span class=\"keyword\">new</span> \\PDO($dsn, $user, $passwd);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(\\PDOException $e) &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> $e -&gt;getMessage();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>*yum源没有freetds<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www6.atomicorp.com/channels/atomic/centos/7/x86_64/RPMS/atomic-release*rpm</div><div class=\"line\">rpm -Uvh atomic-release*rpm</div><div class=\"line\">yum install freetds</div></pre></td></tr></table></figure></p>\n","tags":[{"name":"php","slug":"php","permalink":"http://tanwenhai.github.com/tags/php/"}]},{"title":"数据库软件推荐","date":"2017-02-14T07:11:12.000Z","path":"2017/02/14/数据库软件推荐/","text":"DBeaver 支持数据库多Navicat Premium 收费的 这个没有链接地址哦","content":"<p><a href=\"http://dbeaver.jkiss.org/download/\" target=\"_blank\" rel=\"external\">DBeaver</a> 支持数据库多<br>Navicat Premium 收费的 这个没有链接地址哦</p>\n","tags":[{"name":"soft","slug":"soft","permalink":"http://tanwenhai.github.com/tags/soft/"}]},{"title":"10 件在 PHP 7 中不要做的事情","date":"2017-02-14T06:55:16.000Z","path":"2017/02/14/10-件在-PHP-7-中不要做的事情/","text":"不要使用mysql_函数 这一天终于来了，从此你不仅仅“不应该”使用mysql函数。PHP 7 已经把它们从核心中全部移除了，也就是说你需要迁移到好得多的mysqli函数，或者更灵活的 PDO 实现。 不要编写垃圾代码 这一条可能易于理解，但是会变得越来越重要，因为 PHP 7 的速度提升可能会隐藏你的一些问题。不要仅仅满足于你的站点速度，因为迁移到 PHP 7 才让它变快。为了理解速度有多重要，以及如何把事情做得更好，请看一看我们的文章速度优化入门指南。作为一名开发者，你应该总是确保按需加载脚本，尽可能连接它们，编写高效的数据库查询，尽可能使用缓存，以及其它。 不要在文件末尾使用 PHP 闭合标签 你可以看一看，当一个文件以 PHP 代码结尾时，WordPress 多数核心代码都把末尾的 PHP 标签去掉了。实际上，Zend 框架特别禁止了它。PHP 并不需要文件末尾的闭合标签，并且我们可以通过去掉它来保证不会在后面添加任何的空白字符。 不要做不必要的引用传递 我个人不喜欢引用传递。我知道有时候它很实用，但是其它情况下它使代码变得难懂，并且更难预测结果。据说一些人认为它使代码运行更快，但是根据一些 PHP 高级程序员所说，这并不正确。说明引用为什么不好的一个例子是，PHP 内建了shuffle()和sort()。它们修改原始数组，而不是返回处理后的数组，这很不合逻辑。 不要在循环中执行查询 在循环中执行查询非常浪费。它给你的系统施加不必要的压力，并且可能能够在循环外部更快获得相同结果。当我遇到需要这样的情况时，我通常会使用两个分离的查询来解决问题，我会使用它们来构建数据数组。之后我会遍历数组，并不需要在这个过程中执行查询。由于 WordPress 适用于这里，它可能有一些例外。虽然get_post_meta() 会从数据库获取大量数据，如果你正在遍历某个特殊博文的元数据你可以在循环中使用它。这是因为当你第一次调用它的时候，WordPress实际上会获取所有元数据并缓存它们。后续的调用使用这些缓存数据，没有数据库的调用。弄懂这些的最佳方式是阅读函数文档，以及使用类似 Query Monitor 的工具 不要在 SQL 查询中使用* 当然，这个更像 MySQL 的问题，但是我们习惯在 PHP 中编写 SQL 代码，所以都差不多。无论如何，如果可以避免的话，不要在 SQL 查询里使用通配符，尤其是数据库有很多列的时候。你应该明确指定需要哪些行，并且仅仅获取它们。这有助于减少所用资源，保护数据，以及让事情变得尽可能清晰。对于 SQL，你需要了解所有可用的函数，并且尽可能测试其速度。在计算均值、求和或计算类似数值时，要使用 SQL 函数而不是 PHP 函数。如果你不确定某个查询的速度，测试它并且尝试一些其它的编译 – 之后使用最好的那个。 不要信任用户输入 信任用户输入是不明智的。始终校验、过滤、转义、检查并留好退路。用户数据存在三个问题：我们开发者并没有考虑每种可能性，它通常不正确，以及它可能是蓄意破坏。经过周密考虑的系统可以防护这些威胁。要确保使用类似filter_var()的内建函数检查适当的值，以及在处理数据库时转义（或预编译）。WordPress 拥有一些函数来解决问题。详见文章校验、转义和过滤用户数据。 不要故作聪明 你的目标应该是编写优雅的代码，来更清晰地表达你的意图。你可能能够通过将任何东西缩短为一个单词的变量，使用多层的三元逻辑，以及其它手段，从每个页面中优化 0.01 秒。但这只会给你和你周围的人产生大麻烦。合理命名变量，为代码编写文档，优先选择清晰而不是简洁。甚至还可以更好，使用标准的面向对象代码，它本身或多或少就是文档，不需要一大堆内联数值。 不要重新发明轮子 PHP 到现在为止有很长时间了，网站被造出来的时间更长。很可能无论你需要造出什么，一些人之前早就造出来了。不要害怕向他人寻求支持，Github是你的好朋友，Composer也是，Packagist也是。从日志工具到调色工具，从性能分析器到单元测试框架，从 Mailchimp API 到 Twitter Bootstrap，每个东西都可以通过按下按键（或者敲下命令）来获取，使用它们吧！ 不要忽略其它语言 如果你是个 PHP 程序员，现在有个好机会去至少了解 HTML、CSS、JavaScript 和 MySQL。当你能够更好地处理这些语言时，就是重新学习 JavaScript 的时机了。JavaScript 并不是 jQuery，你应该合理地学习 JavaScript 来更高效地使用它。我也打算向你推荐学习面向对象的 PHP，它可以节省时间，并且在代码规模更大时会变得更好。对于类似 C# 和 Java 的语言，在你了解 OOP 之后，它们也更易于理解。通过了解包管理器、构建脚本、CoffeeScript、LESS、SASS、YAML 、脚本引擎和其它强大的工具来扩展你的知识面。我强烈向你推荐看一看其它框架，尤其是 Laravel。当你使用它们出色完成任务时，学习 Ruby、RoR、Android、iPhone 和 Windows Phone 应用开发如何？你可能会认为这毫无意义，因为它们在你的舒适区和工作所需范围之外，但是这就是它们的意义。每种语言都有一些要学习的实用的东西，以及从没碰到的新知识。所有 PHP 顶级开发者都懂得很多其它编程语言，这并非偶然。 来源segmentfault","content":"<ol>\n<li><p>不要使用mysql_函数</p>\n<blockquote>\n<p>这一天终于来了，从此你不仅仅“不应该”使用mysql<em>函数。PHP 7 已经把它们从核心中全部移除了，也就是说你需要迁移到好得多的mysqli</em>函数，或者更灵活的 PDO 实现。</p>\n</blockquote>\n</li>\n<li><p>不要编写垃圾代码</p>\n<blockquote>\n<p>这一条可能易于理解，但是会变得越来越重要，因为 PHP 7 的速度提升可能会隐藏你的一些问题。<br>不要仅仅满足于你的站点速度，因为迁移到 PHP 7 才让它变快。<br>为了理解速度有多重要，以及如何把事情做得更好，请看一看我们的文章速度优化入门指南。作为一名开发者，你应该总是确保按需加载脚本，尽可能连接它们，编写高效的数据库查询，尽可能使用缓存，以及其它。</p>\n</blockquote>\n</li>\n<li><p>不要在文件末尾使用 PHP 闭合标签</p>\n<blockquote>\n<p>你可以看一看，当一个文件以 PHP 代码结尾时，WordPress 多数核心代码都把末尾的 PHP 标签去掉了。实际上，Zend 框架特别禁止了它。<br>PHP 并不需要文件末尾的闭合标签，并且我们可以通过去掉它来保证不会在后面添加任何的空白字符。</p>\n</blockquote>\n</li>\n<li><p>不要做不必要的引用传递</p>\n<blockquote>\n<p>我个人不喜欢引用传递。我知道有时候它很实用，但是其它情况下它使代码变得难懂，并且更难预测结果。<br>据说一些人认为它使代码运行更快，但是根据一些 PHP 高级程序员所说，这并不正确。<br>说明引用为什么不好的一个例子是，PHP 内建了shuffle()和sort()。它们修改原始数组，而不是返回处理后的数组，这很不合逻辑。</p>\n</blockquote>\n</li>\n<li><p>不要在循环中执行查询</p>\n<blockquote>\n<p>在循环中执行查询非常浪费。它给你的系统施加不必要的压力，并且可能能够在循环外部更快获得相同结果。当我遇到需要这样的情况时，我通常会使用两个分离的查询来解决问题，我会使用它们来构建数据数组。之后我会遍历数组，并不需要在这个过程中执行查询。<br>由于 WordPress 适用于这里，它可能有一些例外。虽然get_post_meta() 会从数据库获取大量数据，如果你正在遍历某个特殊博文的元数据你可以在循环中使用它。这是因为当你第一次调用它的时候，WordPress实际上会获取所有元数据并缓存它们。后续的调用使用这些缓存数据，没有数据库的调用。<br>弄懂这些的最佳方式是阅读函数文档，以及使用类似 Query Monitor 的工具</p>\n</blockquote>\n</li>\n<li><p>不要在 SQL 查询中使用*</p>\n<blockquote>\n<p>当然，这个更像 MySQL 的问题，但是我们习惯在 PHP 中编写 SQL 代码，所以都差不多。无论如何，如果可以避免的话，不要在 SQL 查询里使用通配符，尤其是数据库有很多列的时候。<br>你应该明确指定需要哪些行，并且仅仅获取它们。这有助于减少所用资源，保护数据，以及让事情变得尽可能清晰。<br>对于 SQL，你需要了解所有可用的函数，并且尽可能测试其速度。在计算均值、求和或计算类似数值时，要使用 SQL 函数而不是 PHP 函数。如果你不确定某个查询的速度，测试它并且尝试一些其它的编译 – 之后使用最好的那个。</p>\n</blockquote>\n</li>\n<li><p>不要信任用户输入</p>\n<blockquote>\n<p>信任用户输入是不明智的。始终校验、过滤、转义、检查并留好退路。用户数据存在三个问题：我们开发者并没有考虑每种可能性，它通常不正确，以及它可能是蓄意破坏。<br>经过周密考虑的系统可以防护这些威胁。要确保使用类似filter_var()的内建函数检查适当的值，以及在处理数据库时转义（或预编译）。<br>WordPress 拥有一些函数来解决问题。详见文章校验、转义和过滤用户数据。</p>\n</blockquote>\n</li>\n<li><p>不要故作聪明</p>\n<blockquote>\n<p>你的目标应该是编写优雅的代码，来更清晰地表达你的意图。你可能能够通过将任何东西缩短为一个单词的变量，使用多层的三元逻辑，以及其它手段，从每个页面中优化 0.01 秒。但这只会给你和你周围的人产生大麻烦。<br>合理命名变量，为代码编写文档，优先选择清晰而不是简洁。甚至还可以更好，使用标准的面向对象代码，它本身或多或少就是文档，不需要一大堆内联数值。</p>\n</blockquote>\n</li>\n<li><p>不要重新发明轮子</p>\n<blockquote>\n<p>PHP 到现在为止有很长时间了，网站被造出来的时间更长。很可能无论你需要造出什么，一些人之前早就造出来了。不要害怕向他人寻求支持，Github是你的好朋友，Composer也是，Packagist也是。<br>从日志工具到调色工具，从性能分析器到单元测试框架，从 Mailchimp API 到 Twitter Bootstrap，每个东西都可以通过按下按键（或者敲下命令）来获取，使用它们吧！</p>\n</blockquote>\n</li>\n<li><p>不要忽略其它语言</p>\n<blockquote>\n<p>如果你是个 PHP 程序员，现在有个好机会去至少了解 HTML、CSS、JavaScript 和 MySQL。当你能够更好地处理这些语言时，就是重新学习 JavaScript 的时机了。JavaScript 并不是 jQuery，你应该合理地学习 JavaScript 来更高效地使用它。<br>我也打算向你推荐学习面向对象的 PHP，它可以节省时间，并且在代码规模更大时会变得更好。对于类似 C# 和 Java 的语言，在你了解 OOP 之后，它们也更易于理解。<br>通过了解包管理器、构建脚本、CoffeeScript、LESS、SASS、YAML 、脚本引擎和其它强大的工具来扩展你的知识面。我强烈向你推荐看一看其它框架，尤其是 Laravel。<br>当你使用它们出色完成任务时，学习 Ruby、RoR、Android、iPhone 和 Windows Phone 应用开发如何？你可能会认为这毫无意义，因为它们在你的舒适区和工作所需范围之外，但是这就是它们的意义。每种语言都有一些要学习的实用的东西，以及从没碰到的新知识。所有 PHP 顶级开发者都懂得很多其它编程语言，这并非偶然。</p>\n</blockquote>\n</li>\n</ol>\n<p><a href=\"https://segmentfault.com/a/1190000006912969\" target=\"_blank\" rel=\"external\">来源segmentfault</a></p>\n","tags":[{"name":"php","slug":"php","permalink":"http://tanwenhai.github.com/tags/php/"}]}]}